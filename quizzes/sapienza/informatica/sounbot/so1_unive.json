[
  {
    "question": "1) La tecnica di gestione della memoria con paginazione e tabelle delle pagine multilivello porta _______ dimensione della tabella delle pagine in memoria e _____ l’overhead di memoria nelle operazioni di gestione.",
    "options": [
      {
        "text": "\"ad una riduzione della\" e \"può ridurre\"",
        "image": ""
      },
      {
        "text": "\"ad un aumento della\" e \"può aumentare\"",
        "image": ""
      },
      {
        "text": "\"ad un aumento della\" e \"può ridurre\"",
        "image": ""
      },
      {
        "text": "\"ad una riduzione della\" e \"può aumentare\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Le tabelle multilivello riducono l'occupazione di memoria allocando solo le porzioni di tabella effettivamente necessarie per gli indirizzi virtuali utilizzati, eliminando le entry per spazi vuoti. Questo permette di ridurre l'overhead di memoria rispetto a una singola tabella monolitica che richiederebbe allocazione per l'intero spazio virtuale.",
    "hint": "Considera come le tabelle multilivello gestiscono gli spazi di indirizzamento virtuali sparsi o parzialmente utilizzati."
  },
  {
    "question": "2) La tecnica di gestione della memoria con paginazione basata su tabella inversa delle pagine _______ l’indirizzo della memoria secondaria e la tabella ha una dimensione pari alla cardinalità del _______.",
    "options": [
      {
        "text": "\"non memorizza\" e \"numero di pagine riferite\"",
        "image": ""
      },
      {
        "text": "\"non memorizza\" e \"numero di page frame\"",
        "image": ""
      },
      {
        "text": "\"memorizza\" e \"numero di page frame\"",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La tabella inversa mantiene una entry per ogni frame fisico (page frame) anziché per pagina virtuale, riducendo la dimensione proporzionalmente alla memoria fisica disponibile. L'indirizzo della memoria secondaria non è memorizzato nella tabella inversa ma gestito separatamente tramite strutture dati di swap.",
    "hint": "Pensa alla direzione della mappatura: da fisico a virtuale invece che viceversa."
  },
  {
    "question": "3) La tecnica di gestione della memoria con paginazione e sostituzione delle pagine ‘Far’ sostituisce la pagina più lontana nel grafo delle pagine da _______, dove il grafo rappresenta le pagine come _______.",
    "options": [
      {
        "text": "\"l'ultitima pagina riferita\" e \"nodi\"",
        "image": ""
      },
      {
        "text": "\"qualsiasi pagina riferita\" e \"entità\"",
        "image": ""
      },
      {
        "text": "\"qualsiasi pagina riferita\" e \"nodi\"",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "L'algoritmo Far (farthest) sostituisce la pagina il cui prossimo riferimento è più lontano nel futuro tra tutte le pagine attualmente residenti in memoria. Il grafo di riferimento modella le pagine come nodi e le sequenze di accesso come archi tra essi.",
    "hint": "Ricorda che l'algoritmo ottimale guarda al futuro, non al passato, per scegliere la vittima."
  },
  {
    "question": "4) Nella gestione della memoria basata sulla segmentazione si possono verificare errori di traduzione, nella traduzione si controllano i campi _____ e si può avere un’eccezione di _______",
    "options": [
      {
        "text": "\"bit di residenza, di protezione, di lunghezza\" e \"overflow del segmento / protezione del segmento\"",
        "image": ""
      },
      {
        "text": "\"bit di validità\" e \"validità del segmento\"",
        "image": ""
      },
      {
        "text": "\"bit di residenza, e di validitù\" e \"overflow del segmento / protezione del segmento\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Durante la traduzione in segmentazione, il sistema verifica il bit di residenza (presenza in RAM), i bit di protezione (diritti di accesso) e il campo lunghezza (limite del segmento). Se l'offset supera la lunghezza si ha overflow del segmento; se si violano i permessi si ha un'eccezione di protezione.",
    "hint": "Ricorda quali controlli di sicurezza e di validità sono necessari quando si accede a un segmento."
  },
  {
    "question": "5) Le strategie di sostituzione di pagina globali rispetto a quelle locali _______",
    "options": [
      {
        "text": "non ignorano i comportamenti dei singoli processi.",
        "image": ""
      },
      {
        "text": "tengono conto dello stato del processo",
        "image": ""
      },
      {
        "text": "ignorano i comportamenti dei singoli processi.",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Le strategie globali selezionano le vittime da tutti i frame fisici disponibili indipendentemente dal processo proprietario, trattando la memoria come un pool comune. Questo comporta che un processo possa subire sostituzioni causate dal comportamento di altri processi.",
    "hint": "Pensa se la strategia considera l'appartenenza dei frame ai singoli processi quando sceglie la pagina da sostituire."
  },
  {
    "question": "6) La strategia di sostituzione di pagina a orologio _____",
    "options": [
      {
        "text": "è una variante della strategia FIFO",
        "image": ""
      },
      {
        "text": "è una variante della strategia LIFO",
        "image": ""
      },
      {
        "text": "ignora possibili collisioni",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'algoritmo dell'orologio (clock) è una variante della FIFO che utilizza un bit di riferimento per dare una 'seconda chance' alle pagine recentemente usate, evitando di sostituire pagine ancora necessarie. Utilizza una struttura circolare gestita da un puntatore.",
    "hint": "Considera come il bit di riferimento permetta di differenziare questo algoritmo dalla FIFO pura pur mantenendone la struttura base."
  },
  {
    "question": "7) Il modello working set nella gestione della memoria con paginazione si basa sull’osservazione della dipendenza del _______ dalla quantità di memoria per le pagine di un processo.",
    "options": [
      {
        "text": "tasso di page fault",
        "image": ""
      },
      {
        "text": "grado di multiprogrammazione",
        "image": ""
      },
      {
        "text": "tempo in cui una pagina è caricata in memoria",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il modello working set si basa sul principio di località: se la memoria allocata è sufficiente a contenere il working set, il tasso di page fault rimane basso; altrimenti si verifica il thrashing con un aumento drastico dei fault.",
    "hint": "Rifletti su cosa succede quando un processo non ha abbastanza memoria per mantenere le pagine che sta effettivamente usando."
  },
  {
    "question": "8) Il working set definisce un ______ durante l’intervallo di tempo [t – w, t]",
    "options": [
      {
        "text": "tempo limite",
        "image": ""
      },
      {
        "text": "insieme di pagine riferite",
        "image": ""
      },
      {
        "text": "approssimazione",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il working set W(t, w) è definito formalmente come l'insieme delle pagine distinte referenziate dal processo durante l'intervallo temporale [t-w, t], rappresentando la località temporale del programma.",
    "hint": "Ricorda che il working set descrive quali pagine sono state toccate recentemente, non un valore temporale o una approssimazione generica."
  },
  {
    "question": "9) La strategia del working set unito all’algoritmo del clock per gestire i page fault si basa su una ______",
    "options": [
      {
        "text": "lista circolare",
        "image": ""
      },
      {
        "text": "coda di massima priorità",
        "image": ""
      },
      {
        "text": "lista doppiamente linkata",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'algoritmo del clock implementa una politica di sostituzione approximativa LRU utilizzando una lista circolare di frame e un puntatore che scorre come una lancetta d'orologio, controllando il bit di riferimento di ogni pagina.",
    "hint": "L'analogia con l'orologio meccanico suggerisce una struttura dati dove gli elementi sono disposti in cerchio."
  },
  {
    "question": "10) Nella gestione della memoria virtuale, la tecnica di traduzione dell'indirizzo da virtuale a reale si basa sulla tabella delle pagine. Per migliorare le prestazioni della traduzione in alcuni casi tale tabella _____. E Per la miglior gestione della sostituzione di pagine si usano ______",
    "options": [
      {
        "text": "\"può essere tutta o in parte inserita in memoria associativa\" e \"bit di modifica e di riferimento\"",
        "image": ""
      },
      {
        "text": "\"può essere inserita interamente in memoria secondaria\" e \"bit di modifica e di riferimento\"",
        "image": ""
      },
      {
        "text": "\"può essere tutta o in parte inserita in memoria associativa\" e \"variabili globali\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La memoria associativa (TLB) memorizza le traduzioni recenti per velocizzare l'accesso, mentre i bit di modifica (dirty bit) e di riferimento aiutano gli algoritmi di sostituzione a identificare pagine non modificate o poco usate come candidate ideali per la rimozione.",
    "hint": "Pensa alla cache hardware per la traduzione indirizzi e ai bit che indicano se una pagina è stata scritta o letta recentemente."
  },
  {
    "question": "11) Nella tecnica di paginazione per la gestione della memoria, la scelta della dimensione della pagina di piccole dimensioni ______ la frammentazione interna, _____ la quantità di memoria per mantenere il working set di un processo e può ______ la dimensione della tabella delle pagine.",
    "options": [
      {
        "text": "\"può ridurre\" e \"può ridurre\" e \"aumentare\"",
        "image": ""
      },
      {
        "text": "\"può ridurre\" e \"può ridurre\" e \"dimunuire\"",
        "image": ""
      },
      {
        "text": "\"può aumentare\" e \"può aumentare\" e \"aumentare\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Pagine di piccole dimensioni riducono la frammentazione interna poiché lo spreco di memoria nell'ultima pagina parzialmente utilizzata è minore, e permettono un working set più preciso con minore occupazione di memoria. Tuttavia, richiedono un maggior numero di entry nella tabella delle pagine, aumentandone le dimensioni.",
    "hint": "Considera il compromesso tra granularità della memoria e overhead di gestione."
  },
  {
    "question": "12) La tecnica di gestione basata su DMA permette di interagire con il dispositivo ______ e le interruzioni ______",
    "options": [
      {
        "text": "\"indipendentemente dalla CPU\" e \"sono ridotte\"",
        "image": ""
      },
      {
        "text": "\"tramite la CPU\" e \"sono ridotte\"",
        "image": ""
      },
      {
        "text": "\"indipendentemente dalla CPU\" e \"possono aumentare\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il DMA (Direct Memory Access) consente ai dispositivi di trasferire dati direttamente da/verso la memoria senza intervento della CPU per ogni operazione, riducendo significativamente il numero di interruzioni necessarie.",
    "hint": "Pensa al significato di 'Direct' nel contesto del trasferimento dati."
  },
  {
    "question": "13) In un file system quando ad un record fisico corrisponde un record logico si parla di file con ______",
    "options": [
      {
        "text": "record non bloccati",
        "image": ""
      },
      {
        "text": "indipendenza logica",
        "image": ""
      },
      {
        "text": "record bloccanti",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Quando non vi è raggruppamento di record logici all'interno di un unico record fisico, si parla di record non bloccati (unblocked), dove esiste una corrispondenza uno-a-uno tra record logico e fisico.",
    "hint": "Rifletti sul significato di 'blocco' come raggruppamento di record."
  },
  {
    "question": "14) La variazione della posizione fisica di un file rende un hard link non valido e un soft link _____ ",
    "options": [
      {
        "text": "rimane valido",
        "image": ""
      },
      {
        "text": "viene invalidato di conseguenza",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Un hard link punta direttamente all'inode (ai dati fisici), quindi spostando il file originale l'hard link perde il riferimento. Un soft link (symlink) contiene invece il percorso del file: se il file viene spostato, il soft link può essere risolto dinamicamente e rimane funzionale.",
    "hint": "Ricorda la differenza tra puntare ai dati (inode) e puntare a un percorso."
  },
  {
    "question": "15) In un file system la dimensione di un blocco influenza alcuni indici di prestazioni. All’aumentare della dimensione del blocco si osserva ______ e _____",
    "options": [
      {
        "text": "\"un minor spreco di spazio\" e \"un maggior spreco di tempo\"",
        "image": ""
      },
      {
        "text": "\"un minor spreco di spazio\" e \"un minor spreco di tempo\"",
        "image": ""
      },
      {
        "text": "\"un maggior spreco di spazio\" e \"un minor spreco di tempo\"",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Blocchi di grandi dimensioni aumentano la frammentazione interna poiché più spazio viene sprecato negli ultimi blocchi parzialmente pieni dei file. Al contempo, riducono il tempo di accesso complessivo perché richiedono meno operazioni di I/O per leggere la stessa quantità di dati.",
    "hint": "Valuta il compromesso tra efficienza temporale e utilizzo dello spazio."
  },
  {
    "question": "16) Per migliorare le prestazioni del file system con il metodo della allocazione non contigua e tabellare si usa una tabella per memorizzare i puntatori ai blocchi. La sua dimensione cresce con ______",
    "options": [
      {
        "text": "il solo aumentare dei puntatori ai blocchi",
        "image": ""
      },
      {
        "text": "il solo aumentare dei blocchi",
        "image": ""
      },
      {
        "text": "#blocchi x indirizzo di blocco",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Nell'allocazione tabellare (FAT), la tabella contiene una entry per ogni blocco fisico del disco. Ogni entry memorizza l'indirizzo del blocco successivo (o un marker di fine file), quindi la dimensione totale è data dal prodotto tra il numero di blocchi e la dimensione di ogni puntatore/indirizzo.",
    "hint": "Considera quante entry sono necessarie nella tabella e cosa deve contenere ciascuna entry per puntare ai blocchi."
  },
  {
    "question": "17) In una allocazione contigua di file su un dispositivo di memoria secondaria, considerando un disco, i record logici sono ______. Questa tecnica permette generalmente di ottenere ______ prestazioni; inoltre può dare luogo al fenomeno della ______. ",
    "options": [
      {
        "text": "\"fisicamente adiacenti\" e \"buone\" e \"frammentazione interna\"",
        "image": ""
      },
      {
        "text": "\"fisicamente adiacenti\" e \"scarse\" e \"frammentazione esterna\"",
        "image": ""
      },
      {
        "text": "\"fisicamente adiacenti\" e \"scarse\" e \"frammentazione interna\"",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Nell'allocazione contigua i blocchi di un file occupano posizioni consecutive sul disco. Sebbene l'accesso sequenziale sia veloce, le prestazioni globali sono penalizzate dalla difficoltà di trovare spazi contigui liberi, causando frammentazione esterna: lo spazio libero si frammenta in tanti piccoli segmenti isolati tra i file allocati.",
    "hint": "Ricorda che quando i file vengono cancellati, lasciano 'buchi' di varie dimensioni tra i file esistenti."
  },
  {
    "question": "18) In un file system le tecniche di backup e recovery includono backup fisico e logico. Il backup incrementale si applica per _____",
    "options": [
      {
        "text": "il backup logico che memorizza solo i dati del file system che sono stati modificati rispetto al backup precedente",
        "image": ""
      },
      {
        "text": "dati critici o sensibili",
        "image": ""
      },
      {
        "text": "risorse limitate",
        "image": ""
      },
      {
        "text": "ripristino rapido",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il backup incrementale riduce tempo e spazio di archiviazione copiando solo i file modificati o creati dall'ultimo backup effettuato (completo o incrementale). Questo approccio è tipicamente implementato a livello logico, operando su file e directory piuttosto che su settori fisici grezzi.",
    "hint": "Pensa alla differenza tra copiare tutto il disco e copiare solo ciò che è cambiato dall'ultima volta."
  },
  {
    "question": "19) Per effettuare backup e recovery in file system si utilizzano principalmente tecniche di _____. Un backup incrementale si basa su ______. Un backup logico ha il vantaggio di _____.",
    "options": [
      {
        "text": "\"esportazione delle copie\" e \"memorizzazione dei dati critici o sensibili\" e \"garantire i dati in ogni copia\"",
        "image": ""
      },
      {
        "text": "\"ridondanza con copie multiple\" e \"memorizzazione dei soli dati modificati all’ultimo backup\" e \"mantenere la struttura del file system\"",
        "image": ""
      },
      {
        "text": "\"ridondanza con copie multiple\" e \"memorizzazione dei dati di tutti i backup\" e \"mantenere la struttura del file system\"",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Le strategie di backup si fondano sulla ridondanza, creando copie multiple dei dati per garantire la recovery. Il backup incrementale ottimizza le risorse salvando solo le modifiche successive all'ultimo backup, mentre il backup logico preserva la struttura gerarchica del file system (file, directory, attributi) facilitando il ripristino selettivo.",
    "hint": "Distingui tra copia bit-a-bit del disco (fisica) e copia basata sul contenuto logico dei file."
  },
  {
    "question": "20) Nella gestione dei dispositivi di I/O i metodi che comprendo l’ I/O programmato con busy waiting che è caratterizzato da ______.",
    "options": [
      {
        "text": "complessità esponenziale",
        "image": ""
      },
      {
        "text": "la necessità di performance discrete",
        "image": ""
      },
      {
        "text": "semplicità",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "L'I/O programmato con busy waiting (polling) è la tecnica più semplice da implementare: la CPU invia il comando al dispositivo e attende attivamente in un ciclo di polling finché l'operazione non è completata. Non richiede hardware specializzato come i controller DMA o meccanismi di interrupt, ma sacrifica l'efficienza della CPU.",
    "hint": "Considera cosa fa la CPU mentre attende il completamento dell'operazione di I/O."
  },
  {
    "question": "21) Nella gerarchia di gestione dei dispositivi di I/O i gestori degli interrupt ______ dall’utente e si trovano concettualmente ______ dei driver dei dispositivi. Un driver di dispositivo si trova tipicamente ______",
    "options": [
      {
        "text": "\"non sono visibili\" e \"sotto livello\" e \"nel nucleo\"",
        "image": ""
      },
      {
        "text": "\"non sono visibili\" e \"sotto livello\" e \"a livello applicazione\"",
        "image": ""
      },
      {
        "text": "\"visibili\" e \"sotto livello\" e \"nel nucleo\"",
        "image": ""
      },
      {
        "text": "\"visibli\" e \"sotto livello\" e \"a livello applicazione\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "I gestori degli interrupt operano a livello hardware e sono trasparenti all'utente, posizionandosi al di sotto dei driver nella gerarchia. I driver risiedono nel kernel per gestire direttamente l'hardware con privilegi elevati.",
    "hint": "Pensa alla pila protetta del sistema operativo: più si scende, più ci si avvicina all'hardware fisico."
  },
  {
    "question": "22) I sistemi RAID per la gestione dei dischi per incrementare l’affidabilità usano un meccanismo di ______, per incrementare le prestazioni usano _____ ",
    "options": [
      {
        "text": "\"ridondanza\" e \"distribuzione e partizione sulle copie dei dischi trasparenti\"",
        "image": ""
      },
      {
        "text": "\"trasparenza\" e \"copie scalabili orizzontalmente\"",
        "image": ""
      },
      {
        "text": "\"ridondanza\" e \"copie di blocchi di memoria salvati nella memoria secondaria secondo algoritmi appositi\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "I sistemi RAID utilizzano la ridondanza (es. RAID 1, 5, 6) per tollerare guasti hardware, mentre lo striping distribuisce i dati su più dischi per permettere accessi paralleli e aumentare la velocità di trasferimento.",
    "hint": "L'affidabilità richiede copie di sicurezza, mentre le prestazioni beneficiano del lavoro parallelo."
  },
  {
    "question": "23) Gli algoritmo di scheduling del disco di tipo SCAN includono il C-SCAN che _____, le varianti ‘Freeze’ e ‘N-step’ che _____.",
    "options": [
      {
        "text": "\"aumenta inizialmente i tempi di risposta a favore di una maggiore organizzazione dei dati per accessi futuri\" e \"permettono di velocizzare la ricerca\"",
        "image": ""
      },
      {
        "text": "\"riduce la varianza dei tempi di risposta, a scapito del throughput e del tempo medio di risposta\" e \"prevengono l’attesa infinita / riducono la varianza dei tempi di risposta.\"",
        "image": ""
      },
      {
        "text": "\"riduce il tempo di latenza\" e \"possono portare a una lunga latenza di accesso se le richieste sono disperse su posizioni diverse del disco\"",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "C-SCAN offre tempi di attesa più uniformi tra le richieste ma sacrifica leggermente le prestazioni medie. Le varianti Freeze e N-step introducono meccanismi di aging o batching per evitare che richieste lontane attendano indefinitamente.",
    "hint": "C-SCAN è 'più equo' ma meno efficiente dello SCAN semplice; le varianti servono a evitare che qualcuno resti indietro per sempre."
  },
  {
    "question": "24) Il primo algoritmo di scheduling SCAN ricerca del cilindro _____",
    "options": [
      {
        "text": "tempo più breve di seek in una direzione preferita",
        "image": ""
      },
      {
        "text": "tempo più lungo di seek in una direzione preferita",
        "image": ""
      },
      {
        "text": "nessuna delle precedenti",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'algoritmo SCAN muove la testina del disco in una direzione specifica servendo tutte le richieste incontrate lungo il percorso, minimizzando i movimenti della testina (seek time) in quella direzione prima di invertire il senso.",
    "hint": "Immagina un ascensore che sale servendo tutte le chiamate verso l'alto prima di scendere."
  },
  {
    "question": "25) La formattazione di un disco con la tecnica dell’interleaving si applica per gestire il problema ______",
    "options": [
      {
        "text": "della deviazione del cilindro tra le tracce",
        "image": ""
      },
      {
        "text": "della fremmentazione",
        "image": ""
      },
      {
        "text": "della latenza casuale",
        "image": ""
      },
      {
        "text": "della complessità di allucazione dei file",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'interleaving nei dischi gestisce la deviazione del cilindro (cylinder skew) compensando il tempo necessario alla testina per spostarsi tra tracce consecutive, permettendo al settore successivo di arrivare sotto la testina dopo lo spostamento.",
    "hint": "Serve a sincronizzare la rotazione del disco con lo spostamento meccanico della testina tra tracce adiacenti."
  },
  {
    "question": "26) L’algoritmo di scheduling del disco Shortest Seek Time First fornisce ______ rispetto all algoritmo FIFO. ",
    "options": [
      {
        "text": "nessuna delle altre",
        "image": ""
      },
      {
        "text": "throughput maggiore",
        "image": ""
      },
      {
        "text": "throughput minore",
        "image": ""
      },
      {
        "text": "latenza maggiore",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "SSTF seleziona sempre la richiesta più vicina alla posizione corrente della testina, minimizzando il tempo di seek medio e permettendo di servire più richieste per unità di tempo rispetto a FIFO, che elabora le richieste in ordine di arrivo ignorando la posizione fisica.",
    "hint": "Considera come la riduzione del movimento meccanico della testina influenzi il numero di operazioni completate nell'unità di tempo."
  },
  {
    "question": "27) L’algoritmo di scheduling del disco SCAN si basa su una ricerca del cilindro  ______",
    "options": [
      {
        "text": "cercando i dati più vicino alle posizioni correnti delle teste di lettura/scrittura del disco.",
        "image": ""
      },
      {
        "text": "in direzioni variabili quando si raggiunge un estremo",
        "image": ""
      },
      {
        "text": "cercando i dati prioritizzando le posizioni più distanti delle teste di lettura/scrittura del disco",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'algoritmo SCAN muove la testina in una direzione servendo tutte le richieste incontrate fino all'estremo fisico del disco, per poi invertire la direzione e ripetere il processo, simile al comportamento di un ascensore.",
    "hint": "Pensa al movimento dell'ascensore che serve tutte le chiamate in salita fino all'ultimo piano, poi scende."
  },
  {
    "question": "28) Nel sistema operativo Windows, gli oggetti sono nomi di ____",
    "options": [
      {
        "text": "risorse logiche",
        "image": ""
      },
      {
        "text": "risorse fisiche",
        "image": ""
      },
      {
        "text": "collegamenti simbolici",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Nel modello architetturale di Windows, gli oggetti sono astrazioni del kernel che rappresentano risorse logiche come processi, thread, file o semafori, gestiti dall'Object Manager per fornire un'interfaccia uniforme e sicura.",
    "hint": "Ricorda che gli oggetti Windows sono entità software astratte, non componenti hardware fisici."
  },
  {
    "question": "29) Ogni oggetto nel sistema Windows: ",
    "options": [
      {
        "text": "condivide delle risorse con altri oggetti",
        "image": ""
      },
      {
        "text": "nessuna delle due",
        "image": ""
      },
      {
        "text": "\"può essere con o senza nome\" e \"può avere puntatori e handle (hanno significato diverso)\"",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Gli oggetti Windows possono essere anonimi (unnamed) per uso privato o nominati (named) per la condivisione tra processi; inoltre utilizzano handle (riferimenti validi nel contesto di un processo) e puntatori (riferimenti kernel diretti) con scope e privilegi diversi.",
    "hint": "Distingui tra il nome per identificare l'oggetto globalmente e i meccanismi di accesso che differiscono tra spazio kernel e spazio utente."
  },
  {
    "question": "30) In un sistema operativo Windows le interruzioni sono organizzate in livelli di priorità che includono i livelli, nell’ordine, dal basso: _____ e i thread sono schedulati con una disciplina a _____ ",
    "options": [
      {
        "text": "\"hardware e critiche, chiamate differite, chiamate di procedura asincrone, passivo\" e \"Priority Scheduling\"",
        "image": ""
      },
      {
        "text": "\"passivo, chiamate di procedura asincrone, chiamate differite, hardware e critiche\" e \" priorità di code round robin\"",
        "image": ""
      },
      {
        "text": "\"passivo, chiamate di procedura asincrone, chiamate differite, hardware e critiche\" e \"Multilevel Feedback Queue Scheduling\"",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Windows utilizza livelli IRQL crescenti (da passivo a hardware) per gestire le interruzioni, dove livelli superiori possono interrompere inferiori; lo scheduler dei thread implementa code a priorità multiple dove thread della stessa priorità vengono eseguiti in round robin con time slicing.",
    "hint": "Ricorda la gerarchia delle interruzioni software e hardware, e che lo scheduler Windows assegna time slice a parità di priorità."
  },
  {
    "question": "31) Nel sistema operativo Windows, il nucleo NTOS include: ",
    "options": [
      {
        "text": "Le tradizionali chiamate di sistema",
        "image": ""
      },
      {
        "text": "le interfacce utente",
        "image": ""
      },
      {
        "text": "nessuna delle precedenti",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "NTOSKRNL è il componente fondamentale del kernel Windows NT che implementa l'Executive e il microkernel, gestendo direttamente le chiamate di sistema native (Native API) che costituiscono l'interfaccia tra user-mode e kernel-mode.",
    "hint": "Pensa alla differenza tra API di alto livello (Win32) e le primitive di base del sistema operativo."
  },
  {
    "question": "32) Nel sistema operativo Windows, il livello Executive si trova:",
    "options": [
      {
        "text": "sopra al livello nucleo",
        "image": ""
      },
      {
        "text": "sotto al livello applicazione di sistema",
        "image": ""
      },
      {
        "text": "sotto al livello applicazioni utenti",
        "image": ""
      },
      {
        "text": "nel Kernel Executive Layer",
        "image": ""
      },
      {
        "text": "sotto al livello nucleo",
        "image": ""
      }
    ],
    "correctIndex": 4,
    "image": "",
    "code": "",
    "explanation": "In Windows, l'architettura è gerarchica: applicazioni utente → Executive → Kernel. Il Kernel (nucleo) è il livello più basso del sistema operativo, quindi Executive si trova 'sotto' (a un livello inferiore rispetto a) il nucleo.",
    "hint": "Pensa alla classica architettura a cipolla di Windows: applicazioni in alto, kernel in basso."
  },
  {
    "question": "33) Il sistema operativo Linux ha una organizzazione della memoria basata su ______. Le tabelle delle pagine sono organizzate ______. La memoria fisica è divisa in ____",
    "options": [
      {
        "text": "\"algoritmi di scheduling\" e \"in colonne\" e \"blocchi\"",
        "image": ""
      },
      {
        "text": "\"paginazione\" e \"secondo uno schema creato al momento\"  e \"aree di utilizzo\" ",
        "image": ""
      },
      {
        "text": "\"paginazione\" e \"su tre o quattro livelli\" e \"tre zone e in pagine\"",
        "image": ""
      },
      {
        "text": "nessuna delle precedenti",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Linux implementa la memoria virtuale tramite paginazione, utilizzando tabelle delle pagine gerarchiche a multi-livello (3 o 4 livelli a seconda dell'architettura) per mappare indirizzi virtuali a fisici; la memoria fisica è organizzata in frame di pagina raggruppati in zone (DMA, Normal, HighMem) ottimizzate per diversi utilizzi.",
    "hint": "Ricorda l'organizzazione gerarchica delle page table in Linux e la divisione della RAM in aree con vincoli diversi di indirizzamento."
  },
  {
    "question": "34) Il sistema opeartivo Linux: ",
    "options": [
      {
        "text": "e di tipo microkernel ",
        "image": ""
      },
      {
        "text": "è di tipo monolitico, ma con componenti modulari",
        "image": ""
      },
      {
        "text": "ha un kernel organizzato a livelli",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Linux adotta un'architettura monolitica dove tutti i servizi di sistema girano in modalità kernel condividendo lo spazio di indirizzamento, ma differisce dai kernel monolitici tradizionali per la capacità di caricare e scaricare dinamicamente moduli (driver, filesystem) tramite i Loadable Kernel Modules (LKM).",
    "hint": "Pensa alla differenza tra un kernel monolitico statico e la capacità di Linux di caricare driver 'al volo' senza ricompilazione."
  },
  {
    "question": "35) Nel sistema sistema opeartivo Linux con porting si intende:  ",
    "options": [
      {
        "text": "l'esportazione di componenti del kernel",
        "image": ""
      },
      {
        "text": "l'aggiunta di feature da un kernel all'altro",
        "image": ""
      },
      {
        "text": "il processo di modifica del nucleo per supportare una nuova piattaforma",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Il porting del kernel Linux consiste nell'adattare il codice sorgente e le astrazioni hardware-specifiche (architetture diverse da x86, come ARM, MIPS, RISC-V) per permettere l'esecuzione su una nuova piattaforma target, modificando principalmente il codice dipendente dall'architettura (arch/).",
    "hint": "Considera cosa significa 'portare' un software da un sistema ad un altro diverso."
  },
  {
    "question": "36) [GENERAZIONI] Algoritmi di scheduling di processi basati sui quanti di tempo",
    "options": [
      {
        "text": "III Generazione",
        "image": ""
      },
      {
        "text": "IV Generazione",
        "image": ""
      },
      {
        "text": "I generazione",
        "image": ""
      },
      {
        "text": "V Generaione",
        "image": ""
      },
      {
        "text": "II Generazine",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La III generazione (1964-1971) vide l'introduzione dei sistemi time-sharing e multiprogrammazione, dove i quanti di tempo permisero di alternare l'esecuzione di processi sulla CPU per simulare il parallelismo.",
    "hint": "Pensa all'era dei mainframe e del time-sharing quando i sistemi hanno iniziato a gestire più utenti simultaneamente."
  },
  {
    "question": "37) [GENERAZIONI] Definizione e uso della memoria virutale:",
    "options": [
      {
        "text": "III Generazione",
        "image": ""
      },
      {
        "text": "IV Generazione",
        "image": ""
      },
      {
        "text": "I generazione",
        "image": ""
      },
      {
        "text": "V Generaione",
        "image": ""
      },
      {
        "text": "II Generazine",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La memoria virtuale fu sviluppata nella III generazione per superare i limiti della memoria fisica, permettendo l'esecuzione di programmi più grandi della RAM disponibile attraverso la paginazione o segmentazione.",
    "hint": "Considera quando i sistemi hanno iniziato a separare lo spazio degli indirizzi logici dalla memoria RAM fisica."
  },
  {
    "question": "38) [GENERAZIONI] Interfacce grafiche: IV Generazione ",
    "options": [
      {
        "text": "III Generazione",
        "image": ""
      },
      {
        "text": "IV Generazione",
        "image": ""
      },
      {
        "text": "I generazione",
        "image": ""
      },
      {
        "text": "V Generaione",
        "image": ""
      },
      {
        "text": "II Generazine",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Le interfacce grafiche (GUI) si diffusero nella IV generazione con l'avvento dei personal computer e workstation (Xerox, Apple, Microsoft), rendendo l'interazione visuale accessibile agli utenti non tecnici.",
    "hint": "Pensa all'avvento dei personal computer con mouse e finestre, successivo all'era dei mainframe a linea di comando."
  },
  {
    "question": "39) Quale di queste istruzioni dovrebbe essere consentità solo in modalità nucleo disabilitare gli interrupt: _____; leggere il dispositivo che calcola l’ora corrente: _____; impostare il dispositivo che calcola l’ora corrente: ______;",
    "options": [
      {
        "text": "\"anche utente\" e \"anche utente\" e \"solo nucleo\"",
        "image": ""
      },
      {
        "text": "\"solo nucleo\" e \"solo nucleo\" e \"solo nucleo\"",
        "image": ""
      },
      {
        "text": "\"solo utente\" e \"solo nucleo\" e \"anche utente\"",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La disabilitazione degli interrupt può essere invocata anche da modalità utente tramite system call. La lettura dell'ora è un'operazione di sola lettura, non pericolosa, quindi consentita anche in user mode. L'impostazione dell'ora invece modifica lo stato del sistema e richiede privilegi di kernel.",
    "hint": "Distinguere tra operazioni di sola lettura (sicure) e operazioni di scrittura (privilegiate)."
  },
  {
    "question": "40) [architetture ideali] efficienza e prestazioni:",
    "options": [
      {
        "text": "monolitico",
        "image": ""
      },
      {
        "text": "microkernel",
        "image": ""
      },
      {
        "text": "a livelli",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'architettura monolitica offre prestazioni superiori perché evita l'overhead dei cambi di contesto e della comunicazione tra processi tipici dei microkernel, eseguendo tutte le funzioni in modalità kernel.",
    "hint": "Considera l'overhead introdotto dalla comunicazione IPC tra moduli in spazi di indirizzamento diversi."
  },
  {
    "question": "41) [architetture ideali] flessibilità e modificabilità:",
    "options": [
      {
        "text": "monolitico",
        "image": ""
      },
      {
        "text": "microkernel",
        "image": ""
      },
      {
        "text": "a livelli",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'architettura a microkernel sposta i servizi del sistema operativo (come driver e file system) in spazio utente, separandoli dal nucleo essenziale. Questo consente di modificare, aggiornare o aggiungere funzionalità senza intervenire sul kernel, garantendo maggiore flessibilità e facilità di manutenzione rispetto alle architetture monolitiche.",
    "hint": "Pensa a dove risiedono i driver e i servizi del sistema operativo nelle diverse architetture."
  },
  {
    "question": "42) [architetture ideali] isolamento delle funzioni:",
    "options": [
      {
        "text": "monolitico",
        "image": ""
      },
      {
        "text": "microkernel",
        "image": ""
      },
      {
        "text": "a livelli",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Nell'architettura a livelli, il sistema operativo è organizzato in strati gerarchici dove ogni livello comunica solo con quello immediatamente superiore e inferiore attraverso interfacce ben definite. Questa struttura garantisce un rigido isolamento tra le diverse funzionalità, impedendo che un errore in un modulo si propaghi agli altri.",
    "hint": "Considera quale architettura organizza i componenti in strati sovrapposti con comunicazione solo tra livelli adiacenti."
  },
  {
    "question": "43) In un file system che contiene un insieme di record, un record fisico corrisponde a un record logico se si parla di file con :",
    "options": [
      {
        "text": "record definiti",
        "image": ""
      },
      {
        "text": "record non bloccati ",
        "image": ""
      },
      {
        "text": "record bloccati ",
        "image": ""
      },
      {
        "text": "record di dimensioni variabili",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Nei file con record non bloccati, ogni record logico corrisponde esattamente a un record fisico (blocco) su disco, senza raggruppamenti. Al contrario, nei file a record bloccati, più record logici vengono aggregati in un unico blocco fisico per ottimizzare le operazioni di I/O.",
    "hint": "Rifletti sulla differenza tra l'unità logica vista dall'applicazione e l'unità fisica di memorizzazione quando non c'è raggruppamento di dati."
  },
  {
    "question": "44) L'uso di link in un file system permette di creare dei collegamenti ai file. Se un file viene ritoccato fisicamente nel sistema, un eventuale hard link al file ______ e un eventuale soft link ______ .",
    "options": [
      {
        "text": "\"rimane valido\" e \"diventa non più valido\"",
        "image": ""
      },
      {
        "text": "\"rimane valido\" e \"diventa valido\"",
        "image": ""
      },
      {
        "text": "\"diventa non più valido\" e \"rimane valido\"",
        "image": ""
      },
      {
        "text": "\"viene collegato ad un diverso file\" e \"è indefinito\"",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Se un file viene fisicamente rimosso e sostituito con un nuovo file avente lo stesso nome, l'hard link continua a puntare all'inode originale (ora diverso dal nuovo file), rendendolo tecnicamente obsoleto, mentre il soft link, essendo un riferimento al percorso, punterà automaticamente al nuovo file creato con lo stesso nome.",
    "hint": "Considera cosa succede quando un file viene cancellato e ricreato: a cosa punta esattamente un hard link rispetto a un soft link?"
  },
  {
    "question": "45) Considerare un sistema operativo della IV generazione, include la caratteristica \"sviluppo di interfacce grafiche\"?",
    "options": [
      {
        "text": "no, nella V generazione",
        "image": ""
      },
      {
        "text": "no, nella III generazione",
        "image": ""
      },
      {
        "text": "no, nella II generazione",
        "image": ""
      },
      {
        "text": "sì, nella IV generazione",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La quarta generazione di sistemi operativi, legata all'avvento dei personal computer (anni '80-'90), ha introdotto le interfacce grafiche utente (GUI) basate su finestre, icone e puntatori, rendendo l'interazione più intuitiva rispetto alla riga di comando della terza generazione.",
    "hint": "Collega l'avvento del mouse e delle icone visive all'epoca dei primi personal computer commerciali di massa."
  },
  {
    "question": "46) Considerare un sistema operativo della IV generazione, include la caratteristica \"gestione vincoli real-time\"?",
    "options": [
      {
        "text": "no, nella V generazione",
        "image": ""
      },
      {
        "text": "no, nella III generazione",
        "image": ""
      },
      {
        "text": "no, nella II generazione",
        "image": ""
      },
      {
        "text": "sì, nella IV generazione",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La gestione dei vincoli real-time è stata introdotta nei sistemi operativi della III generazione per applicazioni di controllo industriale e sistemi embedded, mentre la IV generazione si distingue principalmente per personal computer e interfacce grafiche.",
    "hint": "Pensa a quando sono nati i primi sistemi real-time per il controllo di processi industriali."
  },
  {
    "question": "47) Considerare un sistema operativo della IV generazione, include la caratteristica \"memoria virtuale\"?",
    "options": [
      {
        "text": "no, nella V generazione",
        "image": ""
      },
      {
        "text": "no, nella III generazione",
        "image": ""
      },
      {
        "text": "no, nella II generazione",
        "image": ""
      },
      {
        "text": "sì, nella IV generazione",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La memoria virtuale è stata sviluppata nei sistemi della III generazione (es. Atlas, 1962) per supportare la multiprogrammazione e superare i limiti della memoria fisica, prima dell'avvento dei PC.",
    "hint": "Ricorda quale generazione ha introdotto la multiprogrammazione e la memoria virtuale per gestire programmi più grandi della RAM disponibile."
  },
  {
    "question": "48) Considerare un sistema operativo della IV generazione, include la caratteristica \"scheduling di processi basato sul tempo\"?",
    "options": [
      {
        "text": "no, nella V generazione",
        "image": ""
      },
      {
        "text": "no, nella III generazione",
        "image": ""
      },
      {
        "text": "no, nella II generazione",
        "image": ""
      },
      {
        "text": "sì, nella IV generazione",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Lo scheduling basato sul tempo (time-sharing) è una caratteristica fondamentale dei sistemi della III generazione, nato per permettere l'accesso interattivo multiutente ai mainframe, mentre la IV generazione si focalizza su GUI e personal computing.",
    "hint": "Considera quando è nato il time-sharing per permettere a più utenti di usare contemporaneamente lo stesso computer in modo interattivo."
  },
  {
    "question": "49) Considerare un sistema operativo per un moderno sistema di elaborazione con connessione ad una rete. Il sistema operativo: ",
    "options": [
      {
        "text": "aumenta il livello di comunicazione fra moduli",
        "image": ""
      },
      {
        "text": "usa un approccio a livelli",
        "image": ""
      },
      {
        "text": "supporta funzioni per connessione alla rete",
        "image": ""
      },
      {
        "text": "nessuna delle precedenti",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Un sistema operativo moderno connesso a una rete deve fornire necessariamente funzionalità di rete come stack protocollari (TCP/IP), driver di rete e API socket per consentire la comunicazione tra sistemi.",
    "hint": "Qual è la funzione primaria e indispensabile di un OS in un ambiente networked?"
  },
  {
    "question": "50) Considerare un sistema operativo per un moderno sistema di elaborazione con connessione ad una rete. Il sistema operativo: ",
    "options": [
      {
        "text": "aumenta il livello di comunicazione fra moduli",
        "image": ""
      },
      {
        "text": "gestisce un sistema connesso alla rete",
        "image": ""
      },
      {
        "text": "usa un approccio a livelli",
        "image": ""
      },
      {
        "text": "gestisce un singolo client connesso alla rete",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il sistema operativo gestisce l'intero sistema hardware e software che è connesso alla rete, coordinando risorse, processi e connessioni, non solo un singolo client o utente.",
    "hint": "L'OS gestisce le risorse dell'intero computer connesso alla rete, non solo di una singola applicazione client."
  },
  {
    "question": "51) I sistemi time-sharing e i sistemi con multiprogrammazione in che relazione sono fra loro?",
    "options": [
      {
        "text": "il sistema time-sharing prevede anche multiprogrammazione",
        "image": ""
      },
      {
        "text": "il sistema time-sharing dipende dal livello di multiprogrammazione",
        "image": ""
      },
      {
        "text": "il sistema con multiprogrammazione può comportarsi come un sistema time-sharing ",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il time-sharing è una evoluzione della multiprogrammazione che permette a più utenti di interagire simultaneamente con il sistema. Per implementare la commutazione rapida della CPU tra processi (round-robin), è necessario che più programmi risiedano contemporaneamente in memoria, il che è proprio la definizione di multiprogrammazione.",
    "hint": "Per alternare rapidamente l'esecuzione tra più utenti, quanti programmi devono essere caricati in memoria contemporaneamente?"
  },
  {
    "question": "52) Considerando gli stati di un processo, se un processo è dispatched se:",
    "options": [
      {
        "text": "passa dallo stato \"Esecuzione\" allo stato \"Pronto\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Esecuzione\" allo stato \"Bloccato\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Bloccato\" allo stato \"Pronto\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Pronto\" allo stato \"Esecuzione\"",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il dispatch è l'azione compiuta dallo scheduler a breve termine (dispatcher) che seleziona un processo dalla coda dei pronti e gli assegna la CPU. Questa transizione avviene quando il processo passa dallo stato di pronto (ready) a quello di esecuzione (running).",
    "hint": "Il dispatcher 'prende' un processo dalla coda dei pronti e lo 'carica' sulla CPU."
  },
  {
    "question": "52) Considerando gli stati di un processo, un processo che riceve una notifica attesa di un evento:",
    "options": [
      {
        "text": "passa dallo stato \"Esecuzione\" allo stato \"Pronto\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Esecuzione\" allo stato \"Bloccato\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Bloccato\" allo stato \"Pronto\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Pronto\" allo stato \"Esecuzione\"",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Quando si verifica l'evento atteso (es. completamento di un'operazione di I/O), il processo viene svegliato (wakeup) e reinserito nella coda dei pronti. Non entra immediatamente in esecuzione, ma deve attendere che lo scheduler gli assegni nuovamente la CPU.",
    "hint": "L'evento sblocca il processo, ma prima di tornare ad eseguire deve competere per la CPU con gli altri processi pronti."
  },
  {
    "question": "53) Considerando gli stati di un processo, se il processo si blocca in attesa di un evento esterno:",
    "options": [
      {
        "text": "passa dallo stato \"Esecuzione\" allo stato \"Pronto\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Esecuzione\" allo stato \"Bloccato\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Bloccato\" allo stato \"Pronto\"",
        "image": ""
      },
      {
        "text": "passa dallo stato \"Pronto\" allo stato \"Esecuzione\"",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Un processo in esecuzione che richiede un'operazione di I/O o attende una risorsa esterna esegue una system call bloccante. Rilascia volontariamente la CPU e passa allo stato bloccato (waiting), permettendo allo scheduler di selezionare un altro processo dalla coda dei pronti.",
    "hint": "Il processo attivo ha bisogno di qualcosa che non è immediatamente disponibile e si mette in attesa."
  },
  {
    "question": "54) In una allocazione contigua di file su un dispositivo di memoria secondaria, considerando un disco, i record logici sono _____ .",
    "options": [
      {
        "text": "dipendenti l'uno dall'altro ",
        "image": ""
      },
      {
        "text": "anche fisici",
        "image": ""
      },
      {
        "text": "fisicamente adiacenti",
        "image": ""
      },
      {
        "text": "fisicamente lontani l'uno dall'altro",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Nell'allocazione contigua, ogni file occupa un insieme di blocchi consecutivi sul disco. I record logici del file sono memorizzati in blocchi fisicamente adiacenti, garantendo un accesso sequenziale efficiente, anche se questo può causare frammentazione esterna.",
    "hint": "Il significato etimologico di 'contiguo' è 'che si tocca, adiacente'."
  },
  {
    "question": "55) L'allocazione contigua di file su un dispositivo di memoria secondaria, considerando un disco, permette generalmente: ",
    "options": [
      {
        "text": "di ottenere ottime prestazioni",
        "image": ""
      },
      {
        "text": "frammentazione interna ",
        "image": ""
      },
      {
        "text": "di ottenere scarse prestazioni",
        "image": ""
      },
      {
        "text": "nessuna delle precedenti",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "L'allocazione contigua richiede blocchi consecutivi sul disco. Nel tempo, la creazione e cancellazione di file genera frammentazione esterna: lo spazio libero si frammenta in segmenti non contigui, rendendo difficile trovare spazio per nuovi file e richiedendo costose operazioni di compattazione.",
    "hint": "Considera cosa succede allo spazio libero quando cancelli file di dimensioni diverse e ne crei di nuovi più grandi."
  },
  {
    "question": "55) L'allocazione contigua di file su un dispositivo di memoria secondaria, considerando un disco, permette generalmente: ",
    "options": [
      {
        "text": "di ottenere ottime prestazioni",
        "image": ""
      },
      {
        "text": "frammentazione interna ",
        "image": ""
      },
      {
        "text": "frammentazione esterna",
        "image": ""
      },
      {
        "text": "nessuna delle precedenti",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "L'allocazione contigua soffre di frammentazione esterna: quando i file vengono cancellati, rimangono 'buchi' di spazio libero tra i file esistenti. Se questi buchi sono troppo piccoli singolarmente, non possono ospitare nuovi file anche se la somma totale dello spazio libero è sufficiente.",
    "hint": "Distingui tra spazio sprecato all'interno dei blocchi assegnati e spazio libero frammentato tra i file allocati."
  }
]