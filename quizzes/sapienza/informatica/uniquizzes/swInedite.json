[
  {
    "question": "Identificare uno svantaggio della modularizzazione",
    "options": [
      {
        "text": "nessuno di questi",
        "image": ""
      },
      {
        "text": "livello di astrazione desiderato può essere inserito nei programmi",
        "image": ""
      },
      {
        "text": "manutenzione più facile con componenti più piccole",
        "image": ""
      },
      {
        "text": "programmi divisi in base ad aspetti funzionali",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Le opzioni B, C e D descrivono tutti vantaggi della modularizzazione (astrazione, manutenzione facilitata, separazione per funzionalità), non svantaggi. Quindi nessuna delle alternative proposte rappresenta uno svantaggio.",
    "hint": "Leggi attentamente se le opzioni descrivono vantaggi o svantaggi della modularizzazione."
  },
  {
    "question": "Quale dei seguenti è un tipo di Modello Architetturale?",
    "options": [
      {
        "text": "Static structural model",
        "image": ""
      },
      {
        "text": "tutti quelli menzionati",
        "image": ""
      },
      {
        "text": "Distribution model",
        "image": ""
      },
      {
        "text": "Dynamic process model",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "I modelli architetturali includono il modello strutturale statico (struttura del sistema), il modello di distribuzione (deploy su hardware) e il modello dinamico di processo (comportamento runtime). Tutti e tre sono tipi validi.",
    "hint": "Ricorda che esistono diverse prospettive per modellare un'architettura software."
  },
  {
    "question": "Quale di queste view mostra che il sistema è composto da processi interagenti a run time",
    "options": [
      {
        "text": "physical",
        "image": ""
      },
      {
        "text": "development",
        "image": ""
      },
      {
        "text": "logical",
        "image": ""
      },
      {
        "text": "process",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La view 'process' si concentra sui processi in esecuzione e sulle loro interazioni durante il runtime del sistema, mostrando come i componenti comunicano.",
    "hint": "Le view architetturali includono Logical, Development, Physical e Process; solo una descrive le interazioni a runtime."
  },
  {
    "question": "Quale/i dei seguenti è un conflitto Architetturale",
    "options": [
      {
        "text": "tutti quelli menzionati",
        "image": ""
      },
      {
        "text": "localizzare caratteristiche di safety in genere richiedo maggiori comunicazioni conridotta efficienza",
        "image": ""
      },
      {
        "text": "componenti a grana grossa migliorano l'efficienza e riducono la manutenibilità",
        "image": ""
      },
      {
        "text": "nessuna",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "I conflitti architetturali sono trade-off tra requisiti contrastanti. L'opzione B descrive il conflitto safety-vs-comunicazione, mentre C descrive efficienza-vs-manutenibilità. Entrambi sono conflitti architetturali.",
    "hint": "Un conflitto architetturale si ha quando due requisiti desiderabili sono in contrapposizione."
  },
  {
    "question": "Quale documento viene creato dal system analyst dopo che i requisiti sono stati raccolti dai vari stakeholders",
    "options": [
      {
        "text": "feasibility study",
        "image": ""
      },
      {
        "text": "software requirement validation",
        "image": ""
      },
      {
        "text": "requirement gathering",
        "image": ""
      },
      {
        "text": "software requirement specification",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il Software Requirement Specification (SRS) è il documento formale che raccoglie e dettaglia tutti i requisiti software dopo la fase di requirement gathering dagli stakeholders.",
    "hint": "È il documento che formalizza i requisiti raccolti; gli altri termini indicano fasi o attività diverse."
  },
  {
    "question": "Coupling è una indicazione qualitativa del fatto che un modulo",
    "options": [
      {
        "text": "si focalizza su una cosa solamente",
        "image": ""
      },
      {
        "text": "è in grado di completare le sue funzioni tempestivamente",
        "image": ""
      },
      {
        "text": "può essere scritto in maniera più compatta",
        "image": ""
      },
      {
        "text": "è connesso ad altri moduli ed l mondo esterno",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il coupling (accoppiamento) misura il grado di interdipendenza tra moduli. Un alto coupling significa che un modulo dipende fortemente da altri moduli e dall'ambiente esterno, mentre un basso coupling indica moduli più indipendenti e manutenibili.",
    "hint": "Pensa all'opposto di 'coesione': se la coesione riguarda cosa succede DENTRO un modulo, il coupling riguarda le relazioni all'ESTERNO."
  },
  {
    "question": "Il primo passo nel Software Development Life Cycle è",
    "options": [
      {
        "text": "analisi",
        "image": ""
      },
      {
        "text": "Identificazione del problema e delle opportunità",
        "image": ""
      },
      {
        "text": "progettazione",
        "image": ""
      },
      {
        "text": "sviluppo e documentazione",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il primo passo del SDLC è l'identificazione del problema e delle opportunità, poiché prima di analizzare, progettare o sviluppare qualsiasi soluzione, è fondamentale capire quale problema si vuole risolvere e quali opportunità esistono.",
    "hint": "Prima di costruire qualcosa, devi sapere COSA costruire e PERCHÉ."
  },
  {
    "question": "L'importanza del software design si può riassumere in una sola parola che è",
    "options": [
      {
        "text": "Qualità",
        "image": ""
      },
      {
        "text": "Complessità",
        "image": ""
      },
      {
        "text": "Precisione",
        "image": ""
      },
      {
        "text": "Efficienza",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il software design è il processo che definisce l'architettura, le componenti e le interfacce per garantire che il prodotto finale soddisfi i requisiti di qualità, incluse affidabilità, manutenibilità e usabilità.",
    "hint": "Il design è il processo che trasforma i requisiti in caratteristiche concrete del prodotto finale."
  },
  {
    "question": "Quale dei seguenti non influenza la qualità del software ed il rendimento dell'organizzazione?",
    "options": [
      {
        "text": "prodotto",
        "image": ""
      },
      {
        "text": "mercato",
        "image": ""
      },
      {
        "text": "tecnologia",
        "image": ""
      },
      {
        "text": "persone",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "I fattori che influenzano la qualità del software e il rendimento organizzativo sono il prodotto stesso, la tecnologia utilizzata e le persone (skill, competenze). Il mercato è un fattore esterno che influenza il business, non direttamente la qualità tecnica del software.",
    "hint": "I 'fattori P' classici della qualità del software sono: prodotto, persone, processo, progetto, piattaforma."
  },
  {
    "question": "Cohesion (coesione) è una indicazione qualitativa del fatto che un modulo",
    "options": [
      {
        "text": "si focalizza su una cosa solamente",
        "image": ""
      },
      {
        "text": "può essere scritto in maniera più compatta",
        "image": ""
      },
      {
        "text": "è in grado di completare le sue funzioni tempestivamente",
        "image": ""
      },
      {
        "text": "è connesso ad altri moduli ed l mondo esterno",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La cohesion (coesione) misura quanto le responsabilità interne di un modulo sono correlate e focalizzate su un singolo scopo. Un'alta coesione significa che il modulo fa 'una cosa sola' in modo efficace, facilitando manutenibilità e comprensibilità.",
    "hint": "Coesione e accoppiamento sono opposti: la coesione riguarda le relazioni DENTRO un modulo, non quelle con l'esterno."
  },
  {
    "question": "Quale tecnica è applicabile quando altri progetti nello stesso dominio di applicazione sono stati completati?",
    "options": [
      {
        "text": "Legge di Parkinson (Il lavoro si espande fino ad occupare tutto il tempo disponibile)",
        "image": ""
      },
      {
        "text": "giudizio di esperti",
        "image": ""
      },
      {
        "text": "modellazione algoritmica dei costi",
        "image": ""
      },
      {
        "text": "stima per analogia",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La stima per analogia utilizza dati storici di progetti precedenti simili nel mismo dominio per stimare costi e durata del nuovo progetto, sfruttando l'esperienza accumulata.",
    "hint": "Si basa sul confronto con progetti passati gia completati."
  },
  {
    "question": "Un ................ si sviluppa usando informazioni storiche sui costi che collegano netriche di software al costo del progetto",
    "options": [
      {
        "text": "stime per analogia",
        "image": ""
      },
      {
        "text": "modello algoritmico dei costi",
        "image": ""
      },
      {
        "text": "legga di Pakinson (Il lavoro si espande fino ad occupare tutto il tempo disponibile)",
        "image": ""
      },
      {
        "text": "giudizio di un esperto",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "I modelli algoritmici dei costi (come COCOMO) usano formule matematiche derivate da dati storici che mettono in relazione metriche del software (dimensione, complessita) con i costi del progetto.",
    "hint": "Utilizza formule e dati storici per calcolare i costi."
  },
  {
    "question": "Quale dei seguenti non si può ottenere con strumenti automatici di stima?",
    "options": [
      {
        "text": "predirre costi del software",
        "image": ""
      },
      {
        "text": "predirre le richieste del cliente",
        "image": ""
      },
      {
        "text": "predirre livelli di personale",
        "image": ""
      },
      {
        "text": "predirre la schedulazione del software",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Gli strumenti automatici di stima possono predire elementi quantificabili come costi, personale e schedulazione, ma le richieste del cliente sono requisiti soggettivi che richiedono comunicazione diretta e non possono essere dedotte automaticamente.",
    "hint": "I requisiti del cliente dipendono dalle esigenze specifiche del progetto."
  },
  {
    "question": "Quale delle seguenti affermazioni sul Model Checking è sbagliata ?",
    "options": [
      {
        "text": "non è computazionalmente oneroso",
        "image": ""
      },
      {
        "text": "esplora tutti i possibili percorsi nel modello",
        "image": ""
      },
      {
        "text": "tutte e tre le menzionate",
        "image": ""
      },
      {
        "text": "è particolarmente utile per verificare sistemi concorrenti",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il Model Checking e computazionalmente oneroso perche deve esplorare tutti i possibili stati e percorsi del sistema, problema noto come 'esplosione combinatoria' degli stati.",
    "hint": "La verifica di tutti i percorsi possibili richiede molte risorse computazionali."
  },
  {
    "question": "Quale modello assume che i sistemi siano creati da componenti riusabili, scripting a programmazione di basi di dati?",
    "options": [
      {
        "text": "post-architecture model",
        "image": ""
      },
      {
        "text": "application-composition model",
        "image": ""
      },
      {
        "text": "reuse model",
        "image": ""
      },
      {
        "text": "early design model",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'application-composition model assume che i sistemi vengano costruiti assemblando componenti riusabili, integrando scripting e programmazione di basi di dati per creare nuove applicazioni.",
    "hint": "Si basa sulla composizione di parti gia esistenti per creare nuovi sistemi."
  },
  {
    "question": "Quake dei seguenti non è una misura diretta di processo di IngSw?",
    "options": [
      {
        "text": "tutti i menzionati",
        "image": ""
      },
      {
        "text": "costo",
        "image": ""
      },
      {
        "text": "efficienza",
        "image": ""
      },
      {
        "text": "sforzo impiegato",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "L'efficienza è una misura derivata (indiretta) che si ottiene rapportando output a input, mentre costo e sforzo impiegato sono misure dirette di processo.",
    "hint": "Distingui tra misure che si rilevano direttamente e quelle che derivano da calcoli."
  },
  {
    "question": "Quale dei seguenti non è considerato un rischio in project management?",
    "options": [
      {
        "text": "testing",
        "image": ""
      },
      {
        "text": "ritardi nelle specifiche",
        "image": ""
      },
      {
        "text": "avvicendamento del personale",
        "image": ""
      },
      {
        "text": "prodotti in competizione",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il testing è un'attività di verifica del software, non un rischio. Le alternative B, C e D rappresentano invece eventi incerti che possono impattare negativamente il progetto.",
    "hint": "Un rischio è un evento incerto negativo, non un'attività di processo."
  },
  {
    "question": "Quale/i di questi parametri principali dovresti usare per calcolare i costi di un progetto di sviluppo software?",
    "options": [
      {
        "text": "costi di hardware e software",
        "image": ""
      },
      {
        "text": "costi di viaggio ed addestramento",
        "image": ""
      },
      {
        "text": "remunerazioni di software engineers e managers",
        "image": ""
      },
      {
        "text": "tutti questi",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il costo totale di un progetto software include tutte le risorse: hardware e software, costi operativi come viaggi e formazione, e il personale (ingegneri e manager).",
    "hint": "I costi di un progetto includono sia costi diretti che indiretti."
  },
  {
    "question": "Lo studio di fattibilità è un'attività volta a",
    "options": [
      {
        "text": "a proporre alcune strategie per la sua realizzazione",
        "image": ""
      },
      {
        "text": "stabilire se un prodotto è tecnicamente realizzabile",
        "image": ""
      },
      {
        "text": "tutti e tre",
        "image": ""
      },
      {
        "text": "stabilire se un prodotto è economicamente conveniente",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Lo studio di fattibilità valuta tre aspetti: fattibilità tecnica, economicità e propone strategie realizzative.",
    "hint": "La fattibilità è una valutazione multidimensionale del progetto."
  },
  {
    "question": "Che relazione c'è tra la modularità di un progetto e l'organizzazione della modalità di sviluppo?",
    "options": [
      {
        "text": "La modularità permette la ripartizione del lavoro fra diversi gruppi di sviluppo.",
        "image": ""
      },
      {
        "text": "la prima permette una modalità distribuita della seconda",
        "image": ""
      },
      {
        "text": "sono la stessa cosa",
        "image": ""
      },
      {
        "text": "nessuna delle tre",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La modularità suddivide il sistema in componenti indipendenti, permettendo a team diversi di lavorare simultaneamente in modo distribuito.",
    "hint": "La divisione in moduli indipendenti abilita il lavoro parallelo dei team."
  },
  {
    "question": "Quali delle seguenti strategie è diretta ad una riduzione dell'impatto del rischio?",
    "options": [
      {
        "text": "tutte e tre",
        "image": ""
      },
      {
        "text": "Minimization strategies",
        "image": ""
      },
      {
        "text": "Avoidance strategies",
        "image": ""
      },
      {
        "text": "Contingency plans",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Le strategie di minimizzazione (risk minimization) sono specificamente dirette a ridurre la probabilità o l'impatto di un rischio quando non è possibile evitarlo completamente, agendo direttamente sull'attenuazione degli effetti negativi.",
    "hint": "La minimizzazione riduce l'impatto, l'avoidance elimina il rischio, i contingency gestiscono l'evento."
  },
  {
    "question": "Quale dei seguenti non è considerato un rischio in Project management?",
    "options": [
      {
        "text": "Testing",
        "image": ""
      },
      {
        "text": "avvicendamento del personale",
        "image": ""
      },
      {
        "text": "ritardi nelle specifiche",
        "image": ""
      },
      {
        "text": "Product competition",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il testing è un'attività di verifica e validazione del prodotto, non un fattore di incertezza. Le altre opzioni rappresentano tutti eventi incerti che possono influenzare negativamente il progetto.",
    "hint": "I rischi sono eventi incerti che possono impedire il raggiungimento degli obiettivi, non attività di progetto."
  },
  {
    "question": "Quali rischi sono associati ai vincoli imposti dal management o dal mercato?",
    "options": [
      {
        "text": "Product size risks",
        "image": ""
      },
      {
        "text": "Process definition risks",
        "image": ""
      },
      {
        "text": "Business impact risks",
        "image": ""
      },
      {
        "text": "Development environment risks",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "I Business impact risks riguardano specifically i vincoli esterni imposti dall'organizzazione o dal contesto di mercato, come limitazioni di budget, scadenze e requisiti aziendali.",
    "hint": "Sono rischi legati all'ambiente esterno e alle decisioni strategiche aziendali."
  },
  {
    "question": "Una risorsa di sistema che ha valore e deve essere protetta si chiama",
    "options": [
      {
        "text": "nessuno di questi",
        "image": ""
      },
      {
        "text": "control",
        "image": ""
      },
      {
        "text": "asset",
        "image": ""
      },
      {
        "text": "vulnerabilità",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Un asset è una risorsa di sistema che possiede valore per l'organizzazione e richiede protezione da minacce, come dati, software, hardware o asset intangibili.",
    "hint": "Non è una vulnerabilità (punto debole) né un controllo (misura di sicurezza)."
  },
  {
    "question": "Le circostanze che hanno il potenziale di causare perdite o danno si chiamano",
    "options": [
      {
        "text": "attacco",
        "image": ""
      },
      {
        "text": "minaccia",
        "image": ""
      },
      {
        "text": "control",
        "image": ""
      },
      {
        "text": "vulnerabilità",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Una minaccia è una circostanza o evento che ha il potenziale di causare perdite o danni a un sistema, violando la sua sicurezza.",
    "hint": "Distingui dalla vulnerabilità che è il punto debole sfruttabile dalla minaccia."
  },
  {
    "question": "Interaction Diagram è un termine composto per",
    "options": [
      {
        "text": "Activity Diagram + State Chart Diagram",
        "image": ""
      },
      {
        "text": "nessuno di questi",
        "image": ""
      },
      {
        "text": "Deployment Diagram + Collaboration Diagram",
        "image": ""
      },
      {
        "text": "Sequence Diagram + Collaboration Diagram",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Interaction Diagram in UML può fare riferimento a diagrammi che modellano interazioni tra oggetti. Activity Diagram e State Chart Diagram sono entrambi diagrammi comportamentali che mostrano il flusso delle attività o gli stati di un sistema.",
    "hint": "In UML esistono diverse categorie di diagrammi: strutturali e comportamentali."
  },
  {
    "question": "Quale/i di questi diagrammi è time-oriented ?",
    "options": [
      {
        "text": "Collaboration",
        "image": ""
      },
      {
        "text": "nessuno di questi",
        "image": ""
      },
      {
        "text": "Sequence",
        "image": ""
      },
      {
        "text": "Activity",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Il Sequence Diagram è orientato al tempo perché mostra esplicitamente la sequenza temporale delle interazioni tra oggetti lungo un asse verticale (timeline).",
    "hint": "Quale diagramma visualizza le interazioni in ordine cronologico?"
  },
  {
    "question": "Quale di questi diagrammi ha una view (visione) statica ?",
    "options": [
      {
        "text": "Activity",
        "image": ""
      },
      {
        "text": "Collaboration",
        "image": ""
      },
      {
        "text": "Use case",
        "image": ""
      },
      {
        "text": "State chart",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "I Use Case Diagram rappresentano le funzionalità del sistema dal punto di vista degli attori, mostrando cosa il sistema fa senza mostrare come lo fa internamente.",
    "hint": "Quale diagramma mostra le funzionalità senza comportamento dinamico?"
  },
  {
    "question": "Quale/i delle seguenti relazioni è/sono valida/e nei Use Case Diagrams ?",
    "options": [
      {
        "text": "Generalization",
        "image": ""
      },
      {
        "text": "Extend",
        "image": ""
      },
      {
        "text": "tutte quelle menzionate",
        "image": ""
      },
      {
        "text": "nessuna",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "In UML, i Use Case Diagrams supportano tre relazioni: Generalization (ereditarietà tra use case), Extend (estensione di un use case) e Include (inclusione di funzionalità comuni).",
    "hint": "Ricorda le tre relazioni base: ereditare, estendere, includere."
  },
  {
    "question": "Identificare la/le affermazione/i vere per gli activity diagrams.",
    "options": [
      {
        "text": "Tutte quelle menzionate",
        "image": ""
      },
      {
        "text": "Sono usati per descrivere il workflow di una particolare attività di business",
        "image": ""
      },
      {
        "text": "Non ci dicono chi fa cosa e non sono riconducibili agli object models",
        "image": ""
      },
      {
        "text": "Possono essere usati per scoprire attività parallele",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Gli Activity Diagram descrivono flussi di lavoro, non mostrano responsabilità specifiche (punto C inteso come limitazione progettuale), e permettono di identificare attività parallele tramite frecce convergenti/divergenti.",
    "hint": "Gli activity diagram si concentrano sul flusso delle attività, non sulla struttura degli oggetti."
  }
]