[
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è falsa?",
    "options": [
      {
        "text": "In un determinato istante, non possono esserci 2 processi distinti con lo stesso PID",
        "image": ""
      },
      {
        "text": "Per creare i PID dei processi si usano dei numeri interi che crescono sempre",
        "image": ""
      },
      {
        "text": "In istanti diversi, possono esserci 2 processi distinti con lo stesso PID",
        "image": ""
      },
      {
        "text": "Ogni processo può conoscere il suo PID",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "I PID in Linux sono numeri interi che, una volta raggiunto il valore massimo configurabile (tipicamente 32767), vengono riutilizzati dal kernel selezionando il primo disponibile in ordine crescente. Non crescono indefinitamente perché lo spazio dei PID è finito.",
    "hint": "Cosa succede quando un sistema rimane acceso per molto tempo e raggiunge il limite massimo di PID?"
  },
  {
    "question": "Quale delle seguenti affermazioni sugli errori delle syscall è vera?",
    "options": [
      {
        "text": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall si può effettuare la seguente chiamata: printf(\"%s\\n\", strerror(errno));",
        "image": ""
      },
      {
        "text": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è sufficiente chiamare perror",
        "image": ""
      },
      {
        "text": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è necessario scrivere uno switch sulla variabile globale errno",
        "image": ""
      },
      {
        "text": "Per stampare su stderr la spiegazione di un errore verificatosi in una syscall, il cui nome sia contenuto nella variabile syscall_name (di tipo char *), si può effettuare la seguente chiamata: perror(\"Si e' verificato il seguente errore nella chiamata a %s\", syscall_name);",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La funzione strerror() converte il codice di errore contenuto in errno in una stringa descrittiva che può essere stampata su qualsiasi stream, incluso stdout. La perror() invece stampa automaticamente su stderr e non accetta stringhe di formato come printf.",
    "hint": "Confronta le signature delle funzioni perror e strerror, e nota dove scrive ciascuna."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Normalmente, il processo figlio, una volta terminata la sua computazione, attende, con una chiamata alla syscall wait, che il padre termini e gli restituisca il suo exit status",
        "image": ""
      },
      {
        "text": "Un processo diventa zombie se termina prima di almeno uno dei processi che abbia eventualmente creato",
        "image": ""
      },
      {
        "text": "Ogni processo può conoscere il proprio PID, ma non quello del processo che l’ha creato",
        "image": ""
      },
      {
        "text": "Con l’eccezione del primo processo, tutti i processi sono creati con una fork effettuata da un altro processo in esecuzione",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il primo processo (init/systemd, PID 1) è creato direttamente dal kernel durante il boot. Tutti gli altri processi derivano da chiamate fork() (o clone()) eseguite da processi genitori già esistenti, formando una gerarchia ad albero.",
    "hint": "Rifletti su come nasce il processo iniziale rispetto a tutti gli altri nel sistema."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è falsa?",
    "options": [
      {
        "text": "Digitare un comando sulla shell genera sempre un nuovo processo",
        "image": ""
      },
      {
        "text": "Esistono file che non possono essere eseguiti per diventare processi",
        "image": ""
      },
      {
        "text": "Affinchè un file possa diventare un processo è necessario che abbia i permessi di esecuzione",
        "image": ""
      },
      {
        "text": "Qualsiasi computazione eseguita dal sistema operativo è contenuta dentro un qualche processo",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "I comandi interni della shell (built-in come cd, export, echo) vengono eseguiti direttamente dal processo shell senza creare un nuovo processo tramite fork(). Solo i comandi esterni generano nuovi processi.",
    "hint": "Distingui tra comandi integrati nell'eseguibile della shell e programmi esterni memorizzati nel filesystem."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Eseguendo (con successo) k volte un file eseguibile, si generano k diversi processi",
        "image": ""
      },
      {
        "text": "Per poter lanciare un file eseguibile, è prima necessario aspettare che il comando precedente sia terminato",
        "image": ""
      },
      {
        "text": "Tutti i processi sono sempre in stato di RUNNING",
        "image": ""
      },
      {
        "text": "Un processo è sempre un’istanza di uno script bash",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Ogni esecuzione di un programma crea un nuovo processo con un proprio PID univoco e uno spazio di indirizzamento indipendente. Anche se si tratta dello stesso file eseguibile, le istanze sono entità distinte gestite separatamente dallo scheduler.",
    "hint": "Considera cosa rende unico un processo oltre al codice che esegue."
  },
  {
    "question": "Un programma scritto in linguaggio C:",
    "options": [
      {
        "text": "Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‘\\n’",
        "image": ""
      },
      {
        "text": "Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‘^M’",
        "image": ""
      },
      {
        "text": "Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‘0’",
        "image": ""
      },
      {
        "text": "Rappresenta le stringhe come array di caratteri terminate dal carattere ‘\\0’",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "In C, le stringhe sono convenzionalmente rappresentate come array di caratteri terminati dal carattere nullo '\\0' (valore ASCII 0), che funge da sentinella per le funzioni di libreria. Non è corretto usare '\\n' (newline) o il carattere '0' (valore ASCII 48) come terminatori.",
    "hint": "Ricorda quale carattere ha valore ASCII 0 e viene usato dalle funzioni come strlen per determinare la fine della stringa."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Linus Torvalds ha riscritto i pacchetti di Unix, creando i pacchetti GNU",
        "image": ""
      },
      {
        "text": "Tutte le opzioni sono false",
        "image": ""
      },
      {
        "text": "Linus Torvalds ha scritto il primo kernel di Linux all’inizio degli anni ‘80",
        "image": ""
      },
      {
        "text": "Richard Stallman ha descritto per primo la licenza GPL",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Richard Stallman, fondatore della Free Software Foundation, descrisse la licenza GPL nel 1989. Linus Torvalds scrisse il kernel Linux nel 1991 (non anni '80), mentre i pacchetti GNU furono sviluppati dal progetto GNU di Stallman, non riscritti da Torvalds.",
    "hint": "Distingui tra il progetto GNU (anni '80, Stallman, GPL) e il kernel Linux (1991, Torvalds)."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      },
      {
        "text": "È possibile montare un filesystem solo se è dichiarato nel file /etc/fstab",
        "image": ""
      },
      {
        "text": "È possibile montare un filesystem solo se è dichiarato nel file /etc/mtab",
        "image": ""
      },
      {
        "text": "Ad ogni filesystem corrisponde un disco fisico o parte di esso(partizione)",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "È possibile montare filesystem manualmente specificando dispositivo e punto di mount senza /etc/fstab. Inoltre, esistono filesystem virtuali (come procfs, sysfs, tmpfs) che non corrispondono a dischi fisici ma risiedono in memoria.",
    "hint": "Considera i filesystem virtuali come /proc o /sys, e ricorda che il comando mount può essere usato con argomenti espliciti."
  },
  {
    "question": "Quale delle seguenti affermazioni sulla comunicazione tra processi in Linux è vera?",
    "options": [
      {
        "text": "Per far comunicare qualunque coppia di processi è necessario metterli in pipeling da shell",
        "image": ""
      },
      {
        "text": "Usando la syscall pipe, è possibile far comunicare qualunque coppia di processi",
        "image": ""
      },
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      },
      {
        "text": "Usando le named pipes, è possibile far comunicare solo processi parenti(ad es., padre con figlio)",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Le pipe anonime (pipe) permettono comunicazione solo tra processi in relazione parentale (padre-figlio), non qualunque coppia. Le named pipes (FIFO) consentono invece comunicazione tra processi non parenti. Il pipelining da shell non è l'unico modo né universale.",
    "hint": "Ricorda che le pipe anonime ereditate dai figli richiedono parentela, mentre le named pipes usano il filesystem come punto di incontro."
  },
  {
    "question": "Quale delle seguenti affermazioni sulla comunicazione tra processi in Linux è vera?",
    "options": [
      {
        "text": "Per far comunicare qualunque coppia di processi è necessario metterli in pipeling da shell",
        "image": ""
      },
      {
        "text": "Usando la syscall pipe, è possibile far comunicare qualunque coppia di processi",
        "image": ""
      },
      {
        "text": "Usando le socket si può far comunicare qualsiasi coppia di processi",
        "image": ""
      },
      {
        "text": "Usando le named pipes, è possibile far comunicare solo processi parenti(ad es., padre con figlio)",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Le socket (Unix domain o di rete) consentono comunicazione bidirezionale tra qualsiasi coppia di processi, indipendentemente dalla loro relazione gerarchica o dalla macchina su cui risiedono, a differenza delle pipe che hanno limitazioni di parentela o filesystem condiviso.",
    "hint": "Le socket sono il meccanismo più versatile di IPC, utilizzabile anche per comunicare tra processi su macchine diverse via rete."
  },
  {
    "question": "Si supponga di avere il seguente frammento di codice: FILE *stream = fopen(NOMEFILE, \"w\"); Dire quale frammento di codice ha lo stesso effetto.",
    "options": [
      {
        "text": "int fd = open(NOMEFILE, O_WRONLY | O_CREAT, 0666);",
        "image": ""
      },
      {
        "text": "int fd = open(NOMEFILE, O_WRONLY | O_TRUNC);",
        "image": ""
      },
      {
        "text": "int fd = open(NOMEFILE, O_WRONLY);",
        "image": ""
      },
      {
        "text": "int fd = open(NOMEFILE, O_WRONLY | O_CREAT | O_TRUNC, 0666);",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La modalità \"w\" di fopen corrisponde alla combinazione di flag O_WRONLY (apertura in scrittura), O_CREAT (creazione del file se non esiste) e O_TRUNC (troncamento a zero se esiste). Il terzo argomento 0666 specifica i permessi di creazione.",
    "hint": "Considera cosa succede al contenuto preesistente del file quando usi la modalità w."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?",
    "options": [
      {
        "text": "Chiamando la syscall select, è possibile monitorare un insieme di file descriptor, ed essere notificati non appena ce n’è uno che è diventato disponibile per un’operazione di lettura o scrittura",
        "image": ""
      },
      {
        "text": "Per richiedere un lock su un file (o su una porzione di esso), occorre chiamare la syscall ioctl",
        "image": ""
      },
      {
        "text": "È possibile usare la syscall select sia in modo bloccante che in modo non bloccante",
        "image": ""
      },
      {
        "text": "Le syscall ioctl e fcntl ammettono 2 o 3 argomenti, a seconda dell’operazione richiesta",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "I lock su file (record locking) si implementano tramite la syscall fcntl con comandi come F_SETLK o F_SETLKW, mentre ioctl è riservata a operazioni specifiche su dispositivi di I/O.",
    "hint": "Pensa a quale syscall gestisce i lock advisory in conformità POSIX."
  },
  {
    "question": "Quale delle seguenti affermazioni sui segnali Linux è vera?",
    "options": [
      {
        "text": "Tutti i segnali, se non opportunamente catturati, provocano la terminazione del processo, con l’eccezione del segnale STOP",
        "image": ""
      },
      {
        "text": "Per un processo è sempre possibile ridefinire il comportamento di un qualsiasi segnale",
        "image": ""
      },
      {
        "text": "È possibile per un qualunque processo inviare un segnale ad un qualsiasi altro processo dello stesso utente",
        "image": ""
      },
      {
        "text": "Nessuna delle altre affermazioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Un processo può inviare segnali a un altro processo dello stesso utente (stesso UID effettivo) tramite la syscall kill, a condizione di avere i permessi necessari. I segnali SIGKILL e SIGSTOP non possono invece essere catturati o ignorati.",
    "hint": "Verifica quali segnali sono incapturabili e chi può inviare segnali a chi."
  },
  {
    "question": "Quale delle seguenti affermazioni sugli errori delle syscall di Linux è vera?",
    "options": [
      {
        "text": "Per stampare su stderr la spiegazione di un errore verificatosi in una syscall, il cui nome sia contenuto nella variabile syscall_name (di tipo char *), si può effettuare la seguente chiamata: perror(\"Si è verificato il seguente errore nella chiamata a %s\", syscall_name);",
        "image": ""
      },
      {
        "text": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall si può effettuare la seguente chiamata: prinf(\"%s\\n\", strerror(errno));",
        "image": ""
      },
      {
        "text": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è sufficiente chiamare perror",
        "image": ""
      },
      {
        "text": "Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è necessario scrivere uno switch sulla variabile globale errno",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La funzione strerror converte il valore di errno in una stringa descrittiva dell'errore, che può essere stampata su stdout tramite printf. La funzione perror invece stampa automaticamente su stderr.",
    "hint": "Distingui tra le funzioni che convertono il codice di errore e quelle che gestiscono l'output su stderr."
  },
  {
    "question": "La stringa Informatica9000 ha un match con la seguente REGEX:",
    "options": [
      {
        "text": "Informatica9000$",
        "image": ""
      },
      {
        "text": "^Informatica900$",
        "image": ""
      },
      {
        "text": "Informatica9[0^3]",
        "image": ""
      },
      {
        "text": "[^IKU]nformatica",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il metacarattere $ in una espressione regolare indica la fine della stringa (end-of-line anchor). Poiché la stringa termina esattamente con \"Informatica9000\", si verifica un match completo.",
    "hint": "Controlla il significato del simbolo $ nel contesto delle regex."
  },
  {
    "question": "Quali delle seguenti affermazioni sui comandi della bash è vera?",
    "options": [
      {
        "text": "Il comando cat stringa può essere usato per scrivere una stringa su stdout",
        "image": ""
      },
      {
        "text": "Eseguendo il comando echo 'date' viene stampata la data e l’ora corrente (secondo l’orologio di sistema)",
        "image": ""
      },
      {
        "text": "Il comando man cmd restituisce in sequenza tutte le pagine di manuale per il comando cmd contenute nelle varie sezioni del manuale",
        "image": ""
      },
      {
        "text": "Il comando clear può essere usato per pulire completamente lo schermo: dopo l’esecuzione, il terminale non conterrà alcuna scritta",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il comando echo con substitution di comando (backticks o $()) esegue il comando interno e ne stampa l'output su stdout. Le altre opzioni sono errate: cat legge file o stdin, non accetta stringhe come argomento; man apre la prima sezione trovata o quella specificata, non tutte in sequenza; clear scrolla il terminale verso l'alto ma non cancella la cronologia.",
    "hint": "Presta attenzione alla sintassi di command substitution e al comportamento effettivo di cat, man e clear rispetto allo standard output."
  },
  {
    "question": "Relativamente alla programmazione bash, la variabile IFS:",
    "options": [
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      },
      {
        "text": "È l’acronimo di Internal Field Splitting",
        "image": ""
      },
      {
        "text": "Rappresenta una variabile contenente la sequenza di tutti i caratteri utilizzati per la separazione in parole (word splitting)",
        "image": ""
      },
      {
        "text": "Rappresenta il carattere utilizzato per la separazione in parole (word splitting)",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "IFS (Internal Field Separator) è una variabile speciale della shell che definisce l'insieme di caratteri utilizzati come separatori per lo word splitting durante l'espansione dei comandi. A differenza di quanto suggerito dall'acronimo 'Splitting', il nome corretto è 'Separator', e può contenere più caratteri contemporaneamente.",
    "hint": "Considera che IFS può contenere sequenze di caratteri multipli, non solo uno singolo."
  },
  {
    "question": "Quale delle seguenti affermazioni sul Linguaggio C è vera? ",
    "options": [
      {
        "text": "Richiede che i programmi siano sempre scritti in file con estensione .c",
        "image": ""
      },
      {
        "text": "Richiede che ogni modulo sia scritto in un file separato, come nel Java",
        "image": ""
      },
      {
        "text": "È stato definito come linguaggio Open Source da Dennis Ritchie",
        "image": ""
      },
      {
        "text": "È stato definito presso i laboratori di ricerca di una compagnia telefonica americana",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il linguaggio C fu sviluppato da Dennis Ritchie e Ken Thompson presso i Bell Laboratories (AT&T) tra il 1969 e il 1973. I Bell Labs erano i laboratori di ricerca della American Telephone and Telegraph Company, una compagnia telefonica americana.",
    "hint": "Pensa alla storia del linguaggio e alla famosa azienda telefonica americana dove furono sviluppati Unix e C."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle funzioni malloc, calloc, realloc e free è falsa?",
    "options": [
      {
        "text": "Le due chiamate calloc(N, sizeof(int)) e realloc(NULL, N*sizeof(int)) hanno sempre lo stesso effetto",
        "image": ""
      },
      {
        "text": "Le due chiamate malloc(N*sizeof(int)) e realloc(NULL, N*sizeof(int)) hanno sempre lo stesso effetto",
        "image": ""
      },
      {
        "text": "Il primo argomento di realloc, quando non NULL, deve contenere il risultato di una precedente chiamata a malloc, calloc o realloc",
        "image": ""
      },
      {
        "text": "I risultati di malloc, calloc e realloc possono essere passati alla funzione free per poter essere riallocati da future malloc, calloc e/o realloc",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La funzione calloc inizializza tutta la memoria allocata a zero, mentre realloc(NULL, size) si comporta esattamente come malloc e non effettua alcuna inizializzazione. Inoltre, calloc gestisce separatamente il numero di elementi e la dimensione, verificando eventuali overflow.",
    "hint": "Confronta il comportamento di calloc e malloc/realloc riguardo all'inizializzazione della memoria allocata."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle funzioni malloc, calloc, realloc e free è falsa?",
    "options": [
      {
        "text": "I risultati di malloc e calloc possono essere passati alla funzione free per poter essere riallocati da future malloc e/o calloc",
        "image": ""
      },
      {
        "text": "Le due chiamate malloc(N*sizeof(int)) e calloc(N, sizeof(int)) hanno sempre lo stesso effetto",
        "image": ""
      },
      {
        "text": "La memoria allocata con malloc e/o calloc viene comunque liberata quando il processo termina, indipendentemente dal fatto di aver o no chiamato la free su ogni zona di memoria allocata",
        "image": ""
      },
      {
        "text": "La memoria allocata da malloc e/o calloc si trova sullo heap",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "malloc alloca memoria grezza senza inizializzarla, mentre calloc inizializza tutti i byte a zero e accetta due parametri distinti (numero di elementi e dimensione singola) anziché il prodotto diretto. Inoltre, calloc include controlli di overflow nella moltiplicazione.",
    "hint": "Verifica se entrambe le funzioni inizializzano la memoria nello stesso modo e come gestiscono i parametri."
  },
  {
    "question": "Quale dei seguenti sistemi operativi non è un antenato di Linux?",
    "options": [
      {
        "text": "Unix",
        "image": ""
      },
      {
        "text": "Le altre risposte contengono tutte degli antenati di Linux",
        "image": ""
      },
      {
        "text": "MacOSX",
        "image": ""
      },
      {
        "text": "MULTICS",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Linux deriva da Unix (e indirettamente da MULTICS, che influenzò la progettazione di Unix), mentre MacOSX discende da BSD/NeXTSTEP ed è contemporaneo o posteriore a Linux, non un suo antenato storico.",
    "hint": "Considera la linea temporale: MULTICS (anni '60) → Unix (anni '70) → Linux (anni '90), mentre MacOSX è degli anni '90 ma su linea evolutiva diversa."
  },
  {
    "question": "Si consideri il comando: find Doc* \\( -name ‘Doc*’ -a -type d \\) -o -newer Documenti -exec touch ‘{}’ \\;",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "L’azione non è specificata correttamente, quindi la bash restituirà un messaggio d’errore",
        "image": ""
      },
      {
        "text": "Il comando stampa su schermo tutte le directory il cui nome comincia con Doc e che siano state modificate più recentemente della directory Documenti",
        "image": ""
      },
      {
        "text": "Il comando modifica tutti i tempi(atime, mtime e ctime) di tutte le directory il cui nome comincia con Doc e che siano state modificate più recentemente dalla directory Documenti",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il comando utilizza l'operatore -o che collega condizioni alternative, selezionando anche file non directory che siano più recenti di Documenti. Inoltre, touch modifica solo atime e mtime (non ctime), e l'uso di -exec impedisce la stampa a schermo.",
    "hint": "Analizza la precedenza degli operatori logici in find e verifica quali timestamp vengono effettivamente modificati dal comando touch."
  },
  {
    "question": "Quale delle seguenti affermazioni sulla syscall fork è falsa?",
    "options": [
      {
        "text": "Ritorna 2 valori diversi a seconda che si tratti del processo padre o del processo figlio",
        "image": ""
      },
      {
        "text": "Genera una copia esatta del processo chiamante, con alcune eccezioni; tra queste ultime vi è lo stack delle chiamate (che quindi non è copiato)",
        "image": ""
      },
      {
        "text": "Genera una copia esatta del processo chiamante, con alcune eccezioni; tra queste ultime vi è il PID (che quindi non è copiato)",
        "image": ""
      },
      {
        "text": "Genera una copia esatta del processo chiamante, con alcune eccezioni; tra queste ultime vi è il PPID (che quindi non è copiato)",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La fork() duplica completamente lo spazio di indirizzamento del processo padre, incluso lo stack delle chiamate, permettendo al figlio di riprendere l'esecuzione esattamente dal punto della fork. Le eccezioni riguardano PID, PPID e valore di ritorno.",
    "hint": "Se lo stack non venisse copiato, come potrebbe il processo figlio conoscere l'indirizzo di ritorno dalla system call?"
  },
  {
    "question": "Quale delle seguenti affermazioni sui comando cmp, diff e patch è vera?",
    "options": [
      {
        "text": "L’opzione -b ha lo stesso significato sia per diff che per cmp",
        "image": ""
      },
      {
        "text": "È possibile usare il comando patch solo se si ha l’output del comando diff",
        "image": ""
      },
      {
        "text": "È possibile usare il comando patch solo se si ha, indifferentemente, l’output del comando diff o del comando cmp",
        "image": ""
      },
      {
        "text": "L’opzione -i di cmp permette di considerare come uguali le differenze sul solo minuscolo/maiuscolo",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il comando patch applica modifiche a file testuali utilizzando il formato specifico prodotto da diff (unified o context diff). cmp confronta file byte per byte e non genera output compatibile con patch.",
    "hint": "Ricorda che cmp è progettato per confronti binari byte-level, mentre diff genera istruzioni di editing applicabili da patch."
  },
  {
    "question": "Si supponga di voler avere in esecuzione in background i comando cmd1 e cmd2 (si supponga anche che tali comandi non terminino, a meno che non gli si mandi un opportuno segnale). Quale dei seguenti modi è corretto?",
    "options": [
      {
        "text": "cmd1 #premere Ctrl+C bg cmd2 #premere Ctrl+C bg",
        "image": ""
      },
      {
        "text": "cmd1 #premere Ctrl+Z cmd2 #premere Ctrl+Z fg",
        "image": ""
      },
      {
        "text": "cmd1 #premere Ctrl+Z cmd2 bg #premere Ctrl+Z bg",
        "image": ""
      },
      {
        "text": "cmd1 #premere Ctrl+Z cmd2 #premere Ctrl+Z bg bg",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Per mettere processi in background è necessario prima sospenderli con Ctrl+Z (SIGTSTP), poi usar bg. La sequenza corretta sospende cmd1, poi cmd2, e infine bg bg mette entrambi in background (agendo prima sull'ultimo job sospeso, poi sul precedente).",
    "hint": "Ctrl+Z sospende il processo in foreground, mentre bg può essere invocato ripetutamente per riattivare job sospesi in background."
  },
  {
    "question": "Si supponga di voler avere in esecuzione in background i comando cmd1 e cmd2. Quale dei seguenti modi è corretto?",
    "options": [
      {
        "text": "cmd1 #premere Ctrl+Z bg cmd2 #premere Ctrl+Z bg",
        "image": ""
      },
      {
        "text": "cmd1 #premere Ctrl+Z fg cmd2 #premere Ctrl+Z fg",
        "image": ""
      },
      {
        "text": "cmd1 #premere Ctrl+Z bg cmd2 #premere Ctrl+Z",
        "image": ""
      },
      {
        "text": "cmd1 #premere Ctrl+Z cmd2 #premere Ctrl+Z fg",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Ctrl+Z sospende il processo in foreground inviando il segnale SIGTSTP; il comando bg successivo lo riprende in background. Va ripetuto per entrambi i comandi per averli entrambi in background contemporaneamente.",
    "hint": "Ricorda che dopo aver sospeso un processo con Ctrl+Z, devi esplicitamente riattivarlo in background con il comando bg."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?",
    "options": [
      {
        "text": "La syscall link(oldpath, newpath) ha lo stesso effetto del comando bash ln oldpath newpath",
        "image": ""
      },
      {
        "text": "La syscall unlink(nomefile) ha lo stesso effetto del comando bash rm nomefile",
        "image": ""
      },
      {
        "text": "La syscall unlink(nomefile) rimuove sempre il contenuto di nomefile dal disco, se nomefile è un file regolare",
        "image": ""
      },
      {
        "text": "La syscall symlink(oldpath, newpath) ha lo stesso effetto del comando bash ln -s oldpath newpath",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "unlink() rimuove solo il riferimento (hard link) al file; il contenuto fisico rimane sul disco finché il contatore dei link non arriva a zero e nessun processo tiene aperto un file descriptor su quel file.",
    "hint": "Considera cosa succede quando esistono multiple hard link o quando un processo ha ancora aperto il file."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Ciascun job è composto al massimo da un processo",
        "image": ""
      },
      {
        "text": "Per vedere i jobs in foreground, è sufficiente usare il comando jobs",
        "image": ""
      },
      {
        "text": "Quando un processo in foreground termina, la bash stampa il job id del processo e la ragione della terminazione",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Un job può comprendere pipeline di più processi (es. cmd1 | cmd2); il comando jobs elenca tutti i job sospesi o in background, non solo quelli in foreground; la bash notifica la terminazione solo per i job in background, non per quelli in foreground.",
    "hint": "Ricorda che un job può essere una pipeline e che le notifiche di terminazione con job ID riguardano i processi in background."
  },
  {
    "question": "Quale delle seguenti affermazioni sulla syscall sigaction è vera?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Permette di definire una funzione che viene eseguita qualsiasi segnale arrivi al processo",
        "image": ""
      },
      {
        "text": "Chiamandola ripetutamente, e passandole al primo argomento via via tutti i segnali disponibili, è possibile definire una funzione che viene eseguita qualsiasi segnale arrivi al processo",
        "image": ""
      },
      {
        "text": "Permette di definire quali segnali vanno ignorati finché l’handler del segnale è in esecuzione",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "sigaction configura il gestore per un singolo segnale specificato come primo argomento; non esiste un handler universale per tutti i segnali, e sa_mask serve a bloccare (mascherare) segnali aggiuntivi durante l'esecuzione dell'handler, non a ignorarli.",
    "hint": "Verifica la differenza tra mascherare (bloccare) e ignorare un segnale, e ricorda che ogni segnale richiede una chiamata separata."
  },
  {
    "question": "Quale delle seguenti affermazioni sulla syscall sigaction è vera?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Permette di definire una funzione che viene eseguita qualsiasi segnale arrivi al processo",
        "image": ""
      },
      {
        "text": "Chiamandola ripetutamente, e passandole al primo argomento via via tutti i segnali disponibili, è possibile definire una funzione che viene eseguita qualsiasi segnale arrivi al processo",
        "image": ""
      },
      {
        "text": "Permette tramite il campo sa_mask della struttura struct sigaction, di definire quali segnali vanno ignorati finché l’handler del segnale è in esecuzione",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "sigaction opera su un segnale specifico per volta, quindi non è possibile definire un unico handler per tutti i segnali con chiamate ripetute; inoltre, il campo sa_mask blocca (maschera) i segnali durante l'esecuzione dell'handler, ma non li ignora.",
    "hint": "Controlla attentamente la terminologia: sa_mask blocca i segnali in arrivo durante l'handler, ma non li ignora permanentemente."
  },
  {
    "question": "Si supponga di voler lanciare in background i comandi cmd1 e cmd2. Quale dei seguenti modi è corretto?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      },
      {
        "text": "cmd1 & cmd2",
        "image": ""
      },
      {
        "text": "( cmd1; cmd2 ) &",
        "image": ""
      },
      {
        "text": "cmd1; cmd2 &",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "In bash, l'operatore & applicato alla fine di un comando lo esegue in background. L'opzione B mette solo cmd1 in background, l'opzione C esegue i comandi in sequenza in un subshell backgroundato, e l'opzione D mette solo cmd2 in background. Per eseguire entrambi in background come job separati servirebbe `cmd1 & cmd2 &`.",
    "hint": "Ricorda che l'operatore & si applica solo al comando che lo precede immediatamente, a meno che non venga usato un raggruppamento."
  },
  {
    "question": "Si supponga di voler lanciare in background i comandi cmd1 e cmd2 (si supponga anche che tali comandi non terminino, a meno che non gli si mandi un opportuno segnale). Quale dei seguenti modi è corretto?",
    "options": [
      {
        "text": "cmd1; cmd2 &",
        "image": ""
      },
      {
        "text": "cmd1 && cmd2",
        "image": ""
      },
      {
        "text": "cmd1 & cmd2",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "L'opzione A esegue cmd1 in foreground e cmd2 in background, l'opzione B esegue entrambi in foreground con dipendenza logica, e l'opzione C esegue solo cmd1 in background lasciando cmd2 in foreground. Per eseguire entrambi in background è necessario usare `cmd1 & cmd2 &`.",
    "hint": "Controlla quanti processi vengono realmente messi in background in ciascuna opzione."
  },
  {
    "question": "Si supponga di voler lanciare in background i comandi cmd1 e cmd2. Quale dei seguenti modi è corretto?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      },
      {
        "text": "cmd1 & cmd2 &",
        "image": ""
      },
      {
        "text": "( cmd1; cmd2 ) &",
        "image": ""
      },
      {
        "text": "cmd1; cmd2 &",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'operatore & posto dopo un comando ne permette l'esecuzione in background. Per lanciare entrambi i comandi come job separati in background è necessario applicare & a ciascuno di essi: `cmd1 & cmd2 &`. Le altre opzioni o eseguono solo uno dei due in background, o li eseguono sequenzialmente in un subshell.",
    "hint": "Ogni comando che deve girare in background necessita del proprio operatore &."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando time è falsa?",
    "options": [
      {
        "text": "Il comando /usr/bin/time cmd ha anche l’effetto di eseguire il comando cmd",
        "image": ""
      },
      {
        "text": "Il comando /usr/bin/time cmd può solo mostrare il tempo (di CPU, di sistema e reale)",
        "image": ""
      },
      {
        "text": "Esistono 2 comandi time: uno è una keyword della bash e l’latro corrisponde ad un file eseguibile (solitamente /usr/bin/time)",
        "image": ""
      },
      {
        "text": "Il comando time cmd, eseguito dalla bash, può solo mostrare il tempo (di CPU, di sistema e reale)",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il comando esterno `/usr/bin/time` (a differenza del builtin della bash) può mostrare statistiche dettagliate oltre ai tempi, come l'uso della memoria, le operazioni di I/O e i cambi di contesto, specialmente con l'opzione `-v`. Quindi non è limitato solo ai tempi di esecuzione.",
    "hint": "Il comando time esterno offre opzioni di formattazione che includono risorse di sistema oltre al tempo."
  },
  {
    "question": "Quale delle seguenti affermazioni sui comandi less e more è falsa?",
    "options": [
      {
        "text": "Sono specialmente utili quando si vuole visualizzare un output molto lungo (che non è possibile visualizzare in un’intera schermata di terminale",
        "image": ""
      },
      {
        "text": "Entrambi permettono di ricercare espressioni regolari",
        "image": ""
      },
      {
        "text": "Per terminarli occorre premere CTRL+C",
        "image": ""
      },
      {
        "text": "Sono entrambi interattivi",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "I pager `less` e `more` si terminano premendo il tasto `q` (quit), non CTRL+C. L'uso di CTRL+C invia un segnale SIGINT che potrebbe interrompere bruscamente il programma lasciando il terminale in uno stato non corretto, mentre `q` permette una terminazione pulita e ordinata.",
    "hint": "Pensa al tasto standard per uscire dalla maggior parte delle applicazioni interattive testuali in Unix."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall wait e waitpid è falsa?",
    "options": [
      {
        "text": "Se una chiamata wait(&status); ha successo, il valore di status coincide con l’exit status del processo figlio appena terminato",
        "image": ""
      },
      {
        "text": "Ogni chiamata wait(&status); è equivalente alla chiamata waitpid(-1, &status, 0)",
        "image": ""
      },
      {
        "text": "Le chiamate alla wait sono sempre bloccanti",
        "image": ""
      },
      {
        "text": "Le chiamate alla waitpid possono non essere bloccanti",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La variabile status non contiene direttamente l'exit status, ma un valore codificato che include informazioni su come il processo è terminato (normalmente, per segnale, etc.). Per estrarre l'exit status vero e proprio è necessario utilizzare la macro WEXITSTATUS(status).",
    "hint": "Ricorda che status è un intero che codifica più informazioni, non solo il valore di ritorno."
  },
  {
    "question": "Relativamente alla programmazione bash, quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "L’acronimo BASH sta per Bourne Advanced Shell",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "È possibile definire array associativi, con la seguente sintassi: declare -A myArray={‘key1’=’value1’, ‘key2’=’value2’}",
        "image": ""
      },
      {
        "text": "Non è possibile definire array associativi",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "BASH sta per Bourne Again Shell, non Advanced. Inoltre, sebbene bash supporti array associativi (dalla v4.0), la sintassi mostrata nell'opzione C è errata (non usa parentesi graffe e virgole, ma parentesi tonde e spazi).",
    "hint": "Verifica l'acronimo di BASH e la sintassi corretta per gli array associativi in bash moderno."
  },
  {
    "question": "Una directory di un filesystem:",
    "options": [
      {
        "text": "Può contenere solo file regolari e altre directory",
        "image": ""
      },
      {
        "text": "Non può mai contenere degli hard disk",
        "image": ""
      },
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      },
      {
        "text": "Ha sempre una directory padre, eventualmente corrisponde a se stessa",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Ogni directory contiene i link speciali \".\" e \"..\", dove \"..\" punta alla directory padre. Per la directory root \"/\", il padre punta a se stessa, evitando cicli infiniti nel filesystem.",
    "hint": "Pensa ai link speciali \".\" e \"..\" nelle directory, specialmente nella root."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?",
    "options": [
      {
        "text": "La syscall chdir ha l’effetto di cambiare l’esecuzione delle sole chiamate ad open che usano path relativi come primo argomento",
        "image": ""
      },
      {
        "text": "La syscall chdir(path) ha lo stesso effetto del comando bash cd path lanciato in una sottoshell",
        "image": ""
      },
      {
        "text": "La syscall rename(oldpath, newpath) ha lo stesso effetto del comando bash cp oldpath newpath",
        "image": ""
      },
      {
        "text": "La syscall chroot ha l’effetto di cambiare l’esecuzione delle sole chiamate ad open che usano path assoluti come primo argomento",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La syscall rename sposta o rinomina un file modificando i link nella directory senza copiare i dati, mentre cp crea una nuova copia fisica del contenuto del file su disco.",
    "hint": "Considera la differenza tra spostare un file e duplicarne il contenuto."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files e che si trovano nella sezione 2 del manuale è falsa?",
    "options": [
      {
        "text": "Mentre le funzioni della libreria standard possono solo agire solo su file regolari, le syscall di Linux possono agire su tutti i tipi di file(regolari, directory, pipe, …)",
        "image": ""
      },
      {
        "text": "Le funzioni della libreria standard agiscono su una struttura di tipo FILE *, mentre le syscall agiscono su un file descriptor interno",
        "image": ""
      },
      {
        "text": "Nessuna delle syscall di Linux accetta come argomento input o output formattato stile printf",
        "image": ""
      },
      {
        "text": "Le syscall Linux permettono solamente le seguenti operazioni: apertura, chiusura, scrittura, lettura, posizionamento",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Le syscall su file includono anche operazioni di controllo come ioctl, fcntl, gestione dei permessi (chmod, chown), link (link, symlink), metadati (stat), e molte altre, non solo le operazioni base di I/O.",
    "hint": "Pensa alle operazioni di controllo, permessi, link simbolici e metadati che si possono fare sui file."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall di Linux che riguardano le directory è falsa?",
    "options": [
      {
        "text": "La syscall readdir, con argomento uguale a quanto ritornato da una precedente opendir avvenuta con successo, ritorna un puntatore ad una struttura struct dirent, che contiene il nome di un file o di una directory contenuta nella directory passata a opendir",
        "image": ""
      },
      {
        "text": "Chiamare la syscall open su una directory può avere successo",
        "image": ""
      },
      {
        "text": "Per poter cambiare il contenuto di una directory occorre aprirla con la syscall opendir",
        "image": ""
      },
      {
        "text": "Per poter leggere il contenuto di una directory occorre aprirla con la syscall opendir",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La funzione opendir (wrapper di syscall) serve per leggere il contenuto di una directory tramite readdir, non per modificarla. Per cambiare il contenuto (creare/cancellare file) si usano syscall come open, mkdir, unlink o rmdir direttamente, senza bisogno di aprire la directory in lettura.",
    "hint": "Pensa alla differenza tra operazioni di lettura (scansione) e operazioni di modifica del contenuto di una directory."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando kill è falsa?",
    "options": [
      {
        "text": "Per mandare il segnale 9 al processo in background con job id 3, è sufficiente scrivere il comando kill -KILL %3",
        "image": ""
      },
      {
        "text": "Per mandare il segnale SIGTERM al processo con PID 19330, è sufficiente scrivere il comando kill -SIGTERM 19330",
        "image": ""
      },
      {
        "text": "Per mandare il segnale SIGINT al processo in background con job id 3, è sufficiente scrivere il comando kill –‘kill -l SIGINT’ %3",
        "image": ""
      },
      {
        "text": "Per mandare il segnale 9 al processo con PID 10, è sufficiente scrivere il comando kill -KILL %10",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il simbolo % prima del numero indica un job ID relativo alla shell corrente, non un PID. Per riferirsi al processo con PID 10 bisogna omettere il percento, scrivendo semplicemente kill -KILL 10.",
    "hint": "Ricorda la differenza tra identificatore di job (job ID) e identificatore di processo (PID) nella sintassi del comando kill."
  },
  {
    "question": "Per eliminare tutte le linee duplicate in un file di testo (senza preoccuparsi dell’ordinamento delle righe) occorre:",
    "options": [
      {
        "text": "utilizzare congiuntamente i comandi sort e uniq",
        "image": ""
      },
      {
        "text": "utilizzare congiuntamente i comandi cat e grep",
        "image": ""
      },
      {
        "text": "utilizzare il comando uniq con opzione -u",
        "image": ""
      },
      {
        "text": "utilizzare il comando uniq",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il comando uniq rimuove solo le linee duplicate adiacenti. Per eliminare tutti i duplicati indipendentemente dalla loro posizione, è necessario prima ordinare il file con sort (che raggruppa i duplicati) e poi applicare uniq.",
    "hint": "Considera il comportamento di uniq quando le linee duplicate non sono consecutive nel file."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle pipe di Linux è vera?",
    "options": [
      {
        "text": "Usando la syscall pipe, vengono automaticamente aperti 2 file descriptor",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Per usare le named pipes, è sempre necessario chiamare la syscall mkfifo",
        "image": ""
      },
      {
        "text": "usando la syscall mkfifo, viene aperto un solo file descriptor",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La syscall pipe() crea una pipe anonima e restituisce due file descriptor nell'array fornito: pipefd[0] per la lettura e pipefd[1] per la scrittura, abilitando la comunicazione unidirezionale tra processi.",
    "hint": "Ricorda cosa restituisce la funzione pipe() nel suo array di interi."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?",
    "options": [
      {
        "text": "La syscall chown(nomefile, -1, gid) ha lo stesso effetto del comando bash chgrp nomefile",
        "image": ""
      },
      {
        "text": "La syscall mkdir(nomedir, mode) ha lo stesso effetto del comando bash mkdir -m mode nomedir",
        "image": ""
      },
      {
        "text": "La syscall dup2(2, 1) ha l’effetto di ridigere lo stdout nello stderr",
        "image": ""
      },
      {
        "text": "La syscall stat(nomefile, buf) ha lo stesso effetto del comando bash stat nomefile",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La syscall stat() popola una struttura dati in memoria (struct stat) con i metadati del file, mentre il comando bash stat formatta e visualizza queste informazioni su stdout in modo leggibile. Hanno effetti diversi a livello di I/O e output.",
    "hint": "Distingui tra l'interfaccia di sistema che manipola strutture dati in memoria e il comando utente che produce output formattato."
  },
  {
    "question": "Gli script sed:",
    "options": [
      {
        "text": "Sono file di testo composti da sequenze di linee che possono essere del tipo N azione, dove N è il numero di linea del file di ingresso che sed sta processando ed azione è un comando Unix da eseguire sulla linea N",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Sono script (es: bash) al cui interno viene allocato il comando sed",
        "image": ""
      },
      {
        "text": "Sono file di testo composti da sequenze di linee del tipo condizione azione, dove la condizione può essere, ad esempio, un numero di linea o una espressione regolare",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Gli script sed seguono la sintassi 'indirizzo azione', dove l'indirizzo (condizione) può essere un numero di riga, un intervallo o un'espressione regolare che seleziona le linee su cui applicare il comando. Questo formato è fondamentale per l'uso dell'opzione -f di sed.",
    "hint": "Ricorda che sed usa il pattern 'indirizzo comando' dove l'indirizzo filtra le righe prima dell'elaborazione."
  },
  {
    "question": "Quale delle seguenti affermazioni sui comandi cat e od è falsa?",
    "options": [
      {
        "text": "I comandi od file e cat file non possono mai dare lo stesso risultato",
        "image": ""
      },
      {
        "text": "I comandi od file e cat file danno lo stesso risultato se file è un file di testo ASCII",
        "image": ""
      },
      {
        "text": "Il comando cat interpreta ogni sequenza di byte letta come un carattere (tipicamente UTF8), e lo stampa",
        "image": ""
      },
      {
        "text": "Il comando od scrive ogni singolo byte letto usando il suo valore numerico",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'affermazione è falsa perché od (octal dump) produce sempre una rappresentazione numerica dei byte (in ottale, esadecimale o decimale), mentre cat visualizza i caratteri interpretati. Anche con file ASCII, od mostrerebbe i valori numerici corrispondenti ai caratteri, non il testo leggibile.",
    "hint": "Considera che od mostra sempre una rappresentazione numerica dei byte, mai il contenuto testuale diretto."
  },
  {
    "question": "Relativamente alla programmazione bash, quale delle seguenti affermazioni sul carattere # è vera?",
    "options": [
      {
        "text": "Rappresenta sempre l’inizio di un commento, con un’unica eccezione: quando è preceduto dal carattere $",
        "image": ""
      },
      {
        "text": "Se è seguito dal carattere !, non rappresenta mai l’inizio di un commento",
        "image": ""
      },
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      },
      {
        "text": "Se presente in uno script, tutto quello che lo segue è sempre considerato commento",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "In bash il carattere # non è sempre un commento: in costrutti come $# (numero di argomenti) o ${#variabile} (lunghezza stringa) ha significato speciale, e #! all'inizio del file è lo shebang. Inoltre, all'interno di stringhe quotate singolarmente può perdere il significato di commento.",
    "hint": "Pensa a contesti come $# o ${#var} dove il cancelletto assume funzioni diverse dal commento."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall dei processi Linux è falsa?",
    "options": [
      {
        "text": "La syscall setuid() permette a qualsiasi processo di cambiare il suo real user ID",
        "image": ""
      },
      {
        "text": "La syscall getuid() permette a qualsiasi processo di conoscere il suo real user ID",
        "image": ""
      },
      {
        "text": "La syscall getppid() ritorna il PID del processo che ha generato quello chiamante (o che lo ha adottato)",
        "image": ""
      },
      {
        "text": "La syscall getpid() ritorna il PID del processo chiamante",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La syscall setuid() ha restrizioni severe: un processo senza privilegi può solo scambiare il real UID con l'effective UID (se il bit set-user-ID è impostato sul file eseguibile), ma non può impostare arbitrariamente il real UID a qualsiasi valore. Solo processi con privilegi elevati possono modificare liberamente gli UID.",
    "hint": "Ricorda che le syscall per modificare gli UID richiedono privilegi specifici o condizioni particolari di sicurezza."
  },
  {
    "question": "Relativamente alla programmazione bash, quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Si può dichiarare esplicitamente il tipo di una variabile, anteponendolo al nome della variabile stessa (es: int count)",
        "image": ""
      },
      {
        "text": "Ad una variabile di tipo intero non è possibile assegnare un valore di tipo diverso, altrimenti il programma termina con un errore",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Non è possibile dichiarare una variabile in sola lettura: una variabile definita in uno script bash è sempre modificabile",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Bash è un linguaggio debolmente tipizzato: non esiste dichiarazione esplicita di tipo come 'int count' (A falsa), le variabili intere (declare -i) convertono silenziosamente valori non numerici a 0 senza terminare il programma (B falsa), e esistono variabili in sola lettura tramite readonly o declare -r (D falsa).",
    "hint": "Ricorda che bash gestisce le variabili principalmente come stringhe e supporta esplicitamente l'attributo readonly."
  },
  {
    "question": "Relativamente alla programmazione bash, quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Si può dichiarare esplicitamente il tipo di una variabile, anteponendolo al nome della variabile stessa (es: int count)",
        "image": ""
      },
      {
        "text": "Ad una variabile di tipo intero non è possibile assegnare un valore di tipo diverso, altrimenti il programma termina con un errore",
        "image": ""
      },
      {
        "text": "Una volta dichiarato il tipo di una variabile, lo si può cambiare solo dopo aver invocato il comando unset",
        "image": ""
      },
      {
        "text": "Non è possibile dichiarare una variabile in sola lettura: una variabile definita in uno script bash è sempre modificabile",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "In bash, quando si dichiara una variabile con un tipo specifico tramite `declare` (es. `-i` per interi), l'attributo persiste finché la variabile non viene rimossa con `unset`. Solo dopo è possibile ridichiarla con un diverso tipo, poiché bash mantiene i metadati della variabile fino alla sua eliminazione esplicita.",
    "hint": "Ricorda che in bash le variabili mantengono i loro attributi di tipo anche quando cambi valore, a meno che non vengano esplicitamente rimosse."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando ps è vera?",
    "options": [
      {
        "text": "Senza nessun argomento, mostra tutti i processi lanciati dall’utente attuale nel terminale attuale",
        "image": ""
      },
      {
        "text": "Per ogni processo, mostra sempre il suo PID, indipendentemente dagli argomenti con cui viene lanciato",
        "image": ""
      },
      {
        "text": "Non è possibile usarlo per vedere i processi lanciati dall’utente root",
        "image": ""
      },
      {
        "text": "È possibile usarlo per vedere solo i processi che superano un certo uso della RAM",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il comando `ps` senza argomenti mostra per default i processi associati al terminale corrente (TTY) dell'utente che esegue il comando. Questo comportamento è definito dallo standard POSIX e mostra solo i processi del session leader associato al terminale.",
    "hint": "Pensa a cosa succede quando apri un terminale e lanci semplicemente `ps` senza opzioni: quali processi vedi immediatamente?"
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Per ogni terminale aperto, ci può essere al massimo un job in background",
        "image": ""
      },
      {
        "text": "Per lanciare un processo in modo tale che non scriva su stdout, lasciando così modo di scrivere altri comandi sulla bash, è sufficiente lanciarlo in background",
        "image": ""
      },
      {
        "text": "Se si vuole dare input da stdin senza redirezioni ad un processo, è necessario lanciarlo in foreground",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "I processi in background non possono leggere dal terminale (stdin) perché riceverebbero il segnale SIGTTIN che li sospende; per interagire interattivamente con un processo tramite tastiera è necessario che sia in foreground, ovvero il processo di controllo del terminale.",
    "hint": "Cosa succede a un processo in background che tenta di leggere dall'input? Ricorda il segnale che riceve."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Il text segment contiene le istruzioni da eseguire, e non può essere condiviso con altri processi",
        "image": ""
      },
      {
        "text": "Lo stack contiene i dati statici inizializzati ed alcune costanti d’ambiente",
        "image": ""
      },
      {
        "text": "Il processo control block (PCB) mantiene le informazioni essenziali di ogni processo, e uno stesso PCB può essere condiviso tra processi diversi",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il text segment è condivisibile tra processi (es. eseguibili multipli o dopo fork con copy-on-write), lo stack contiene variabili locali e contesto di esecuzione mentre i dati statici inizializzati risiedono nel data segment, e il PCB è una struttura dati unica per ogni processo gestita dal kernel.",
    "hint": "Analizza attentamente ogni segmento di memoria: il codice può essere condiviso? Dove risiedono davvero le variabili statiche? Il PCB è unico o condiviso?"
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è falsa?",
    "options": [
      {
        "text": "I comandi builtin della bash generano sempre nuovi processi",
        "image": ""
      },
      {
        "text": "Per capire se un comando della bash è o no builtin, è sufficiente usare il comando type",
        "image": ""
      },
      {
        "text": "Il comando cd è builtin della bash",
        "image": ""
      },
      {
        "text": "Un comando builtin della bash non corrisponde ad alcun file eseguibile dedicato",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "I comandi builtin della bash (come `cd`, `echo`, `pwd`) vengono eseguiti direttamente dal processo della shell senza creare un nuovo processo figlio tramite fork/exec, al contrario dei comandi esterni che richiedono la creazione di un nuovo processo.",
    "hint": "Perché `cd` deve essere necessariamente builtin e non un comando esterno? Pensa all'ambiente della shell."
  },
  {
    "question": "Quale dei seguenti campi non è presente nel process control block?",
    "options": [
      {
        "text": "Change time",
        "image": ""
      },
      {
        "text": "GID reale ed effettivo",
        "image": ""
      },
      {
        "text": "Nice",
        "image": ""
      },
      {
        "text": "Current working directory",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il Process Control Block (PCB) contiene metadati essenziali per la gestione del processo come stato, registri, UID/GID, nice value e working directory, ma non include 'change time', che è un attributo dei file (inode) relativo ai metadati del filesystem.",
    "hint": "Pensa alla differenza tra attributi di un processo in esecuzione e attributi di un file sul disco."
  },
  {
    "question": "Quale delle seguenti affermazioni sui comandi della bash è falsa?",
    "options": [
      {
        "text": "Il comando type file mostra il tipo del file (regolare, directory, etc)",
        "image": ""
      },
      {
        "text": "Il comando whoami mostra lo username dell’utente attualmente loggato nel terminale in cui viene digitato il comando (potrebbe non coincidere con l’utente che ha effettuato il login grafico)",
        "image": ""
      },
      {
        "text": "Il comando id può essere usato per visualizzare i gruppi cui un utente appartiene",
        "image": ""
      },
      {
        "text": "Il comando which cmd mostra qual è il file eseguibile che viene eseguito quando si lancia il comando cmd, ma solo per i comando che non sono builtin",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il comando `type` in bash indica come un comando verrebbe interpretato (builtin, alias, funzione o eseguibile), mentre per determinare il tipo di file (regolare, directory, etc.) si utilizza il comando `file`.",
    "hint": "Esiste un comando specifico per identificare il tipo di file che ha un nome diverso da 'type'."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall dei processi in Linux è vera?",
    "options": [
      {
        "text": "Se un processo viene lanciato nel seguente modo: var=valore ./a.out, allora esso può ottenere var con la chiamata a getenv(\"valore\");",
        "image": ""
      },
      {
        "text": "Per qualsiasi processo è possibile conoscere il suo ambiente di esecuzione senza effettuare alcuna syscall",
        "image": ""
      },
      {
        "text": "Se un processo viene lanciato nel seguente modo: var=valore ./a.out, allora esso può ottenere valore con la chiamata a setenv(\"var\",\"valore\", 1);",
        "image": ""
      },
      {
        "text": "Se un processo viene lanciato nel seguente modo: var=valore ./a.out, allora esso può ottenere valore con la chiamata a putenv(\"var=valore\");",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'ambiente di esecuzione è accessibile al processo tramite il terzo argomento del main (char **envp) o la variabile globale environ, senza necessità di system call. Le altre opzioni confondono funzioni di lettura (getenv) con quelle di scrittura (setenv/putenv) o invertono chiave e valore.",
    "hint": "Ricorda che il main può accettare tre argomenti, e il terzo contiene già l'ambiente."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Linux è multiutente, perché definisce più utenti, di cui però uno solo può essere loggato su una data macchina",
        "image": ""
      },
      {
        "text": "Linux è multiutente, perché definisce più utenti; in un dato istante, possono esistere 2 o più processi appartenenti ad utenti diversi",
        "image": ""
      },
      {
        "text": "Linux è multiprocesso, perché permette a più utenti contemporaneamente di essere loggati sulla stessa macchina",
        "image": ""
      },
      {
        "text": "Linux è multiprocesso, perché puù essere usato su una macchina con più processi",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Linux è multiutente perché permette a processi di utenti diversi di coesistere simultaneamente sul sistema, indipendentemente dal login interattivo. L'opzione A è falsa perché supporta login multipli contemporanei, mentre C e D confondono il concetto di multiprocesso con quello di multiutente.",
    "hint": "Distingui tra la capacità di ospitare più utenti (multiutente) e la capacità di eseguire più programmi (multiprocesso)."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Linux è multiutente, perché definisce più utenti, di cui però uno solo può essere loggato su una data macchina",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Linux è multiprocesso, perché permette a più utenti contemporaneamente di essere loggati sulla stessa macchina",
        "image": ""
      },
      {
        "text": "Linux è multiprocesso, perché puù essere usato su una macchina con più processi",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'opzione A è falsa perché Linux permette login multipli simultanei. L'opzione C confonde multiutente con multiprocesso. L'opzione D è imprecisa: essere multiprocesso significa gestire l'esecuzione concorrente, non semplicemente 'essere usato' su macchine con più processi.",
    "hint": "Verifica attentamente le definizioni di multiutente e multiprocesso rispetto alle affermazioni specifiche."
  },
  {
    "question": "Il linguaggio C:",
    "options": [
      {
        "text": "È incompatibile con i Sistemi Operativi della famiglia Windows",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "È un linguaggio strutturato e compilato",
        "image": ""
      },
      {
        "text": "E un linguaggio non strutturato e compilato",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Il C è un linguaggio procedurale/strutturato che organizza il codice in funzioni e blocchi di controllo, ed è compilato in linguaggio macchina prima dell'esecuzione. È pienamente compatibile con Windows tramite compilatori come MSVC o MinGW.",
    "hint": "Rifletti sul paradigma di programmazione del C e sulla trasformazione del codice sorgente in eseguibile."
  },
  {
    "question": "Quale delle seguenti non è un possibile stato di un processo Linux?",
    "options": [
      {
        "text": "Uninterruptible sleep",
        "image": ""
      },
      {
        "text": "Stopped",
        "image": ""
      },
      {
        "text": "Running",
        "image": ""
      },
      {
        "text": "Continued",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "\"Continued\" non è uno stato di scheduling dei processi Linux. Quando un processo stoppato riceve SIGCONT, transiziona direttamente nello stato Running (o Runnable). Gli stati kernel standard sono Running, Sleeping (interruptible/uninterruptible), Stopped e Zombie.",
    "hint": "Cosa succede a livello di stato quando un processo fermo riceve il segnale di continuazione?"
  },
  {
    "question": "Quale delle seguenti non è un possibile stato di un processo Linux?",
    "options": [
      {
        "text": "Uninterruptible sleep",
        "image": ""
      },
      {
        "text": "Stopped",
        "image": ""
      },
      {
        "text": "Running",
        "image": ""
      },
      {
        "text": "Orphaned",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "\"Orphaned\" descrive una condizione relativa nella gerarchia dei processi (figlio il cui genitore è terminato), non uno stato di scheduling. Un processo orfano viene adottato da init/systemd e continua la sua esecuzione in uno stato standard come Running o Sleeping.",
    "hint": "Distingui tra gli stati di esecuzione dello scheduler e le relazioni gerarchiche tra processi."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando top è vera?",
    "options": [
      {
        "text": "Se lanciato con il comando top, per terminarlo è necessario premere CTRL+C",
        "image": ""
      },
      {
        "text": "Il suo output è uguale a quello di ps, ma le opzioni sono diverse",
        "image": ""
      },
      {
        "text": "Se lanciato con il comando top -b, per terminarlo è sufficiente premere il tasto Q",
        "image": ""
      },
      {
        "text": "Nessuna delle altre affermazioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "top fornisce una vista dinamica aggiornata in tempo reale, diversamente da ps che offre un'istantanea statica. In modalità batch (-b) il comando è non-interattivo, quindi non può essere terminato premendo Q. In modalità interattiva si usa il tasto q, non necessariamente CTRL+C.",
    "hint": "Considera le differenze tra modalità interattiva e batch, e come top differisce da ps nel comportamento dell'output."
  },
  {
    "question": "Relativamente alla programmazione bash, quali delle seguenti affermazioni è esatta?",
    "options": [
      {
        "text": "Il comando $count[3] stampa il quarto elemento dell’array count",
        "image": ""
      },
      {
        "text": "Il comando $count[3] stampa l’elemento con indice 3 dell’array count. Gli array in bash sono sparsi quindi non c’è garanzia che si tratti del terzo o del quarto elemento dell’array",
        "image": ""
      },
      {
        "text": "Il comando $count[3] stampa il terzo elemento dell’array count",
        "image": ""
      },
      {
        "text": "Nessuna delle opzioni",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La sintassi $count[3] è errata per l'accesso agli array in bash. Senza parentesi graffe, bash espande $count (primo elemento) e concatena la stringa \"[3]\". La sintassi corretta richiede obbligatoriamente ${count[3]}.",
    "hint": "Verifica la sintassi corretta per l'espansione di variabili e l'indicizzazione degli array in bash: le parentesi graffe sono opzionali o obbligatorie?"
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Per visualizzare i processi attualmente in esecuzione su una determinata bash, è sufficiente usare il comando jobs",
        "image": ""
      },
      {
        "text": "Tutti i processi in background sono in stato Stopped",
        "image": ""
      },
      {
        "text": "Per riportare in foreground un determinato job in background, è sufficiente dare il comando fg sulla bash dove il job è in background, ma solo se tale job è l’attuale \"current job\"in background",
        "image": ""
      },
      {
        "text": "Per stoppare un processo in foreground, si può sia mandare un segnale SIGTSTP che premere CTRL+Z in una qualsiasi shell",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Il comando fg, quando invocato senza argomenti, agisce esclusivamente sul job corrente (indicato dal simbolo + nell'output di jobs), riportandolo in foreground. Per riattivare un job diverso è necessario specificare esplicitamente il job ID (es. fg %1).",
    "hint": "Rifletti sulla differenza tra job della shell e processi di sistema, e su come fg seleziona il job senza argomenti espliciti."
  },
  {
    "question": "Per modificare tutte le occorrenze della lettera o ed i rispettivamente in O ed 1 di un file di testo, quale comando è più appropriato utilizzare?",
    "options": [
      {
        "text": "awk",
        "image": ""
      },
      {
        "text": "sed",
        "image": ""
      },
      {
        "text": "grep",
        "image": ""
      },
      {
        "text": "tr",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "sed è uno stream editor progettato per trasformare testo in modo non interattivo, permettendo sostituzioni multiple tramite espressioni regolari (es. sed 's/o/O/g; s/i/1/g'), mentre tr gestisce solo singoli caratteri e grep/awk hanno funzioni diverse.",
    "hint": "Pensa a quale comando permette sostituzioni multiple complesse basate su pattern in un file."
  },
  {
    "question": "Si supponga di voler vedere, per tutti i processi dell’utente utente, il suo PID, il suo PPID, il comando usato per lanciare il processo (con tutti gli argomenti), la sua occupazione totale di memoria in kB e la sua attuale occupazione di memoria in RAM (senza considerare quindi la parte eventualmente swappata su disco), sempre in kB. Quale dei seguenti comandi è quello corretto?",
    "options": [
      {
        "text": "ps -uutente -o pid,ppid,cmd,rss,vsz",
        "image": ""
      },
      {
        "text": "ps -uutente -o pid,ppid,cmd,rss,sz",
        "image": ""
      },
      {
        "text": "ps -e -o pid,ppid,cmd,vsz,rss",
        "image": ""
      },
      {
        "text": "ps -uutente -o pid,ppid,cmd,vsz,rss",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "L'opzione vsz (Virtual Memory Size) indica la memoria virtuale totale in kB (inclusa la parte swappata), mentre rss (Resident Set Size) indica solo la memoria fisica residente in RAM; l'opzione -u filtra correttamente per l'utente specifico.",
    "hint": "Ricorda la differenza tra memoria virtuale totale e memoria fisica residente, e quali opzioni di ps le rappresentano."
  },
  {
    "question": "Una espressione regolare:",
    "options": [
      {
        "text": "È composta da caratteri literal e caratteri di punteggiatura",
        "image": ""
      },
      {
        "text": "Non può essere formata da soli caratteri non literal",
        "image": ""
      },
      {
        "text": "Descrive implicitamente un insieme di stringhe che hanno almeno un match con se stessa",
        "image": ""
      },
      {
        "text": "Non può essere formata da soli caratteri literal",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Un'espressione regolare definisce un pattern formale che descrive un insieme di stringhe che soddisfano determinate condizioni sintattiche, permettendo il riconoscimento di sequenze specifiche all'interno di testi.",
    "hint": "Considera cosa rappresenta concettualmente una regex rispetto all'insieme delle stringhe che riconosce."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Ogni risorsa di un sistema Unix, ad eccezione dei processi e periferiche hardware, è rappresentato da un file",
        "image": ""
      },
      {
        "text": "Ogni risorsa di un sistema Unix, ad eccezione delle connessioni di rete (socket), è rappresentato da un file",
        "image": ""
      },
      {
        "text": "Ogni risorsa di un sistema Unix, ad eccezione dei processi, è rappresentato da un file",
        "image": ""
      },
      {
        "text": "In un sistema Unix tutte le risorse sono rappresentate da un file",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La filosofia Unix 'everything is a file' tratta la maggior parte delle risorse (dispositivi, pipe, socket) come file attraverso un'interfaccia uniforme, ma i processi sono gestiti dal kernel come entità distinte con proprie strutture dati e system call dedicate.",
    "hint": "Pensa alla filosofia Unix 'everything is a file' e a quale risorsa fondamentale richiede system call specifiche anziché operazioni su file descriptor."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Ogni risorsa di un sistema Unix, ad eccezione dei processi e periferiche hardware, è rappresentato da un file",
        "image": ""
      },
      {
        "text": "Ogni risorsa di un sistema Unix, ad eccezione delle connessioni di rete (socket), è rappresentato da un file",
        "image": ""
      },
      {
        "text": "Ogni risorsa di un sistema Unix, ad eccezione dei stampanti, è rappresentato da un file",
        "image": ""
      },
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "In Unix vigono la filosofia \"everything is a file\": processi (/proc), dispositivi hardware (/dev), socket di rete e persino le stampanti sono rappresentati come file nel filesystem. Pertanto le eccezioni indicate nelle opzioni A, B e C sono errate.",
    "hint": "Ricorda il principio fondamentale \"everything is a file\" dei sistemi Unix-like."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando kill è vera?",
    "options": [
      {
        "text": "È obbligatorio specificare il segnale da inviare, come numero intero",
        "image": ""
      },
      {
        "text": "Lanciato senza nessun argomento, manda SIGKILL all’ultimo processo lanciato",
        "image": ""
      },
      {
        "text": "Può essere usato per ottenere lo stesso risultato tanto del CTRL+C quanto del CTRL+Z",
        "image": ""
      },
      {
        "text": "Nessuna delle altre affermazioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "CTRL+C invia il segnale SIGINT (interruzione), mentre CTRL+Z invia SIGTSTP (sospensione). Il comando kill può inviare entrambi questi segnali (es. kill -INT o kill -TSTP), replicando il comportamento delle combinazioni da tastiera.",
    "hint": "Pensa a quali segnali specifici corrispondono le combinazioni da tastiera CTRL+C e CTRL+Z."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Ogni processo è identificato da un PID e da un job id, che devono coincidere",
        "image": ""
      },
      {
        "text": "Un job è un comando della bash che prende sempre il controllo dello stdin",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Fissato un istante nell’esecuzione del sistema operativo, ci sarà sempre al massimo un job in foreground, mentre quelli in background possono essere più d’uno",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "In una shell interattiva, il controllo del terminale (stdin) può essere detenuto da un solo job alla volta (foreground), mentre è possibile eseguire contemporaneamente più job in background. Il job ID è diverso dal PID e identifica il job all'interno della shell.",
    "hint": "Considera la differenza tra foreground e background riguardo al controllo del terminale."
  },
  {
    "question": "Si supponga che sia appena stata eseguita la seguente riga di codice di un processo: int pid = fork();. Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Nel processo padre, la variabile pid vale assume 1 solo valore, corrispondente al suo stesso PID",
        "image": ""
      },
      {
        "text": "Nel processo figlio, la variabile pid vale assume 1 solo valore, corrispondente al PID del padre",
        "image": ""
      },
      {
        "text": "C’è un nuovo processo pronto per andare in esecuzione, a meno che la variabile pid non valga -1",
        "image": ""
      },
      {
        "text": "Nel processo padre, la variabile pid assume 2 diversi valori",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La funzione fork() crea un nuovo processo duplicando il chiamante. Ritorna 0 nel processo figlio, il PID del figlio nel padre, e -1 in caso di errore senza creare alcun processo. Quindi, se il valore di ritorno non è -1, un nuovo processo è stato creato con successo.",
    "hint": "Ricorda i tre possibili valori di ritorno di fork() e cosa rappresentano nel padre e nel figlio."
  },
  {
    "question": "Quali delle seguenti affermazioni sulla variabile IFS è vera?",
    "options": [
      {
        "text": "Può essere usato per cambiare l’esecuzione di un ciclo for della bash",
        "image": ""
      },
      {
        "text": "Contiene il carattere utilizzato per la separazione in token da awk",
        "image": ""
      },
      {
        "text": "Nessuna delle opzioni è vera",
        "image": ""
      },
      {
        "text": "Deve contenere, come valore, un solo carattere, da usare per la separazione in parole nella bash (word splitting)",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "IFS (Internal Field Separator) definisce i caratteri delimitatori usati dalla shell per lo \"word splitting\". Modificando questa variabile si altera il comportamento dei cicli for e dell'espansione di variabili, permettendo ad esempio di iterare su righe anziché su parole.",
    "hint": "Pensa a come la shell utilizza IFS per dividere le stringhe in token durante l'espansione."
  },
  {
    "question": "Quale delle seguenti affermazioni sui processi Linux è vera?",
    "options": [
      {
        "text": "Il process control block mantiene le informazioni essenziali di ogni processo, è mantenuto su disco e viene swappato in RAM quando il processo va in esecuzione",
        "image": ""
      },
      {
        "text": "Lo heap contiene i dati statici inizializzati ed alcune costanti d’ambiente",
        "image": ""
      },
      {
        "text": "Il text segment contiene le istruzioni da eseguire, e viene sempre mantenuto interamente in RAM",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il PCB è mantenuto in RAM kernel, non su disco. Lo heap contiene dati dinamici allocati a runtime, mentre i dati statici inizializzati risiedono nel data segment. Il text segment può essere soggetto a demand paging e swapping, quindi non è garantito che sia sempre interamente residente in RAM.",
    "hint": "Rifletti sulla collocazione fisica delle strutture di controllo e sulla natura dei vari segmenti di memoria virtuale."
  },
  {
    "question": "Quale dei seguenti linguaggi non è mai stato usato per implementare Unix?",
    "options": [
      {
        "text": "L’assembler del PDP7",
        "image": ""
      },
      {
        "text": "Il B",
        "image": ""
      },
      {
        "text": "Il C",
        "image": ""
      },
      {
        "text": "Le altre risposte contengono tutte dei linguaggi usati per implementare Unix",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Unix fu inizialmente sviluppato in assembler per il PDP-7, poi riscritto nel linguaggio B (precursore del C), e infine reimplementato in C per garantire portabilità. Tutti e tre i linguaggi sono stati effettivamente utilizzati nelle varie fasi storiche.",
    "hint": "Ricorda l'evoluzione storica dei linguaggi di implementazione di Unix dagli anni '70."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle espressioni regolari è vera?",
    "options": [
      {
        "text": "Il metacarattere + consente di concatenare due regex",
        "image": ""
      },
      {
        "text": "Non è mai stato possibile definire un match con il carattere .",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Un carattere literal ha un match con se stesso",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Nelle espressioni regolari, un carattere letterale (non metacarattere) corrisponde esattamente a se stesso nel testo di input. Il metacarattere + è invece un quantificatore che indica 'uno o più' dell'elemento precedente, non un operatore di concatenazione.",
    "hint": "Distingui tra metacaratteri speciali (come quantificatori) e caratteri che rappresentano se stessi."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Il file system di Linux è una foresta ovvero un albero con più radici (una per ogni dispositivo fisico di memoria di massa collegato alla macchina, per esempio hard disk, chiave USB, CD, DVD, …)",
        "image": ""
      },
      {
        "text": "Nel file system di Linux, ogni nodo interno è un file o una directory, mentre le foglie sono sempre directory",
        "image": ""
      },
      {
        "text": "Nel file system di Linux esistono anche directory (denominate virtuali) che non si trovano su nessun dispositivo fisico di memoria di massa",
        "image": ""
      },
      {
        "text": "Il file System di Linux è gerarchico, perché per accedere ad un file occorre effettuare una chiamata di sistema al kernel",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Linux supporta filesystem virtuali come procfs (/proc) e sysfs (/sys) che risiedono solo in memoria e forniscono interfacce alle strutture dati del kernel senza backing storage fisico. Il filesystem è un albero singolo con radice /, non una foresta di alberi separati.",
    "hint": "Pensa ai filesystem che espongono informazioni del kernel e non hanno un corrispondente fisico su disco."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando find è falsa?",
    "options": [
      {
        "text": "È possibile restringere la ricerca ai soli file che sono link simbolici",
        "image": ""
      },
      {
        "text": "È obbligatorio che gli starting point siano delle directory",
        "image": ""
      },
      {
        "text": "È possibile cercare nomi di file che rispettino un dato pattern o una data regular expression",
        "image": ""
      },
      {
        "text": "È possibile cercare anche directory, e non solo file",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il comando find può accettare anche file singoli come starting point, non solo directory. In tal caso processa semplicemente quel percorso specifico senza tentare di attraversare un albero di directory.",
    "hint": "Considera cosa succede se esegui find passando come argomento un file regolare invece di una directory."
  },
  {
    "question": "Quale delle seguenti affermazioni sul filesystem Linux è vera?",
    "options": [
      {
        "text": "Tutte le opzioni sono false",
        "image": ""
      },
      {
        "text": "È logicamente unico ed ha come punto di inizio la root (radice) rappresentata dal simbolo /",
        "image": ""
      },
      {
        "text": "Tutte le opzioni sono vere",
        "image": ""
      },
      {
        "text": "È una struttura ad albero in cui le directory sono nodi intermedi e non possono mai essere nodi terminali",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il filesystem Linux adotta una struttura gerarchica ad albero rovesciato con radice unica rappresentata da /. Tutti i dispositivi e le partizioni vengono montati sotto questa gerarchia, creando un namespace logicamente unificato indipendentemente dalla distribuzione fisica dei dati.",
    "hint": "Considera come Linux gestisce il mount dei dispositivi rispetto ai sistemi con lettere di unità separate."
  },
  {
    "question": "Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Non è possibile definire una basic REGEX che abbia un match con una stringa formata da 3 o più occorrenze del carattere *",
        "image": ""
      },
      {
        "text": "Il metacarattere ^ consente di dichiarare un match ad inizio stringa solo se compare come primo carattere della REGEX",
        "image": ""
      },
      {
        "text": "@ è un metacarattere delle REGEX estese",
        "image": ""
      },
      {
        "text": "Tutte le risposte sono vere",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Nelle espressioni regolari, il metacarattere ^ funge da ancoraggio per l'inizio della stringa (o riga) soltanto quando posizionato come primo carattere del pattern. In altre posizioni perde il significato speciale o viene interpretato letteralmente.",
    "hint": "Verifica cosa succede se inserisci il simbolo ^ nel mezzo di una regex."
  },
  {
    "question": "Quale delle seguenti affermazioni sui comandi cat e od è falsa?",
    "options": [
      {
        "text": "L’opzione -A di od permette di scegliere la base (decimale, ottale od esadecimale) di tutti i bytes da stampare",
        "image": ""
      },
      {
        "text": "L’opzione -n di cat fa precedere ogni riga stampata con il numero della riga stessa (a partire da 1)",
        "image": ""
      },
      {
        "text": "L’opzione -E di cat stampa anche il carattere $ alla fine di ogni riga",
        "image": ""
      },
      {
        "text": "L’opzione -j B di od permette di cominciare la visualizzazione a partire dal (B + 1)-esimo byte",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'opzione -A di od (octal dump) determina la base numerica per la visualizzazione degli offset di file (indirizzi), non per i dati stessi. Per specificare la base dei byte si utilizza l'opzione -t o le opzioni specifiche come -x, -o, -d.",
    "hint": "Controlla nel manuale cosa controlla esattamente il flag -A rispetto al formato di output."
  },
  {
    "question": "Quale delle seguenti affermazioni è falsa?",
    "options": [
      {
        "text": "Il carattere \\ ha un match con la regex ‘\\’",
        "image": ""
      },
      {
        "text": ". è un metacarattere che ha un match con una occorrenza di qualsiasi carattere",
        "image": ""
      },
      {
        "text": "I mecataratteri [] consentono di definire il match con un range di caratteri",
        "image": ""
      },
      {
        "text": "La concatenazione di due o più regex è una regex",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Nelle regex il backslash è il carattere di escape. Per effettuare il match con un backslash letterale è necessario utilizzare la sequenza '\\\\' (doppio backslash), poiché la regex '\\' è sintatticamente invalida o interpreta il backslash come escape del carattere successivo.",
    "hint": "Ricorda che per cercare un metacarattere bisogna 'sfuggirlo' con il backslash, ma il backslash stesso è un metacarattere."
  },
  {
    "question": "Il linguaggio C:",
    "options": [
      {
        "text": "Viene definito per la creazione del primo Sistema Operativo Unix",
        "image": ""
      },
      {
        "text": "Nasce negli anni 70 per sviluppare programmi portabili su diverse architetture hardware",
        "image": ""
      },
      {
        "text": "Nasce come linguaggio di programmazione proprietario per l’implementazione dei programmi sui sistemi DEC PDP-11",
        "image": ""
      },
      {
        "text": "Nasce negli anni 70 come evoluzione del linguaggio B",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Dennis Ritchie sviluppò il C ai Bell Labs nei primi anni '70 come evoluzione del linguaggio B (creato da Ken Thompson). Il C mantenne la filosofia di sistema ma aggiunse tipi di dati e altre caratteristiche che lo resero adatto alla riscrittura di Unix.",
    "hint": "Pensa alla sequenza storica dei linguaggi sviluppati ai Bell Labs: BCPL, poi B, poi il successore."
  },
  {
    "question": "Esiste in unix un comando che consente di stampare il numero di occorrenze di una riga di un file?",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è ver",
        "image": ""
      },
      {
        "text": "No, occorre utilizzare congiuntamente i comandi uniq e wc",
        "image": ""
      },
      {
        "text": "No, occorre utilizzare congiuntamente i comandi sort e wc",
        "image": ""
      },
      {
        "text": "Si",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il comando `uniq -c` conta e stampa il numero di occorrenze di ciascuna riga in un file (tipicamente dopo averlo ordinato con `sort`). Pertanto, esiste effettivamente un comando che svolge questa funzione senza necessità di combinare altri comandi.",
    "hint": "Pensa al comando `uniq` con il flag che conta le occorrenze."
  },
  {
    "question": "Quali tra le seguenti affermazioni è vera?",
    "options": [
      {
        "text": "cat -N -6 filename stampa le ultime 6 ighe del filename",
        "image": ""
      },
      {
        "text": "tail -c n filename stampa le ultime n righe del filename",
        "image": ""
      },
      {
        "text": "cut consente di tagliare un file in gruppi di righe contigue in base a un carattere di spaziatura",
        "image": ""
      },
      {
        "text": "nessuna delle altre risposte è vera",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "L'opzione `-N` di `cat` numera le righe ma non limita l'output alle ultime righe. `tail -c` specifica il numero di byte, non di righe. Il comando `cut` estrae campi o colonne basandosi su delimitatori, non gruppi di righe contigue.",
    "hint": "Verifica le funzionalità specifiche di ciascun comando riguardo alla manipolazione delle righe."
  },
  {
    "question": "Quali tra le seguenti affermazioni è vera?",
    "options": [
      {
        "text": "È possibile stampare esclusivamente le ultime N righe di un file di testo con il comando cat -N -6",
        "image": ""
      },
      {
        "text": "Il comando tail -c /var/log/maillog stampa in maniera continua le ultime righe del file /var/log/maillog",
        "image": ""
      },
      {
        "text": "Il comando cut consente di selezionare (scrivendole in output) singole righe di un file",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "`cat -N` aggiunge solo i numeri di riga senza filtrare le ultime righe. `tail -c` richiede un argomento numerico per i byte e l'opzione `-f` (non `-c`) serve per l'output continuo. `cut` opera su campi delimitati, non sulla selezione di righe specifiche.",
    "hint": "Controlla il comportamento esatto dei flag di ciascun comando e il loro scopo principale."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle applicazioni client-server realizzate tramite socket è vera?",
    "options": [
      {
        "text": "Il client deve sempre chiamare la syscall bin",
        "image": ""
      },
      {
        "text": "Il server deve chiamare la syscall connect",
        "image": ""
      },
      {
        "text": "Il client deve sempre chiamare la syscall listen",
        "image": ""
      },
      {
        "text": "Sia il server che il client devono sempre chiamare la syscall socket",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Sia il client che il server devono creare un endpoint di comunicazione chiamando `socket()` per ottenere un file descriptor. Successivamente, il server utilizzerà `bind()`, `listen()` e `accept()`, mentre il client userà `connect()`.",
    "hint": "Considera il passaggio iniziale richiesto ad entrambe le parti per creare un punto di comunicazione prima di qualsiasi connessione."
  },
  {
    "question": "Si supponga di voler scrivere un programma immune al CTRL+C. Quali dei seguenti frammenti di codice realizza quanto detto sopra?",
    "options": [
      {
        "text": "signal(SIGTERM, SIG_DFL);",
        "image": ""
      },
      {
        "text": "signal(SIGINT, SIG_DFL);",
        "image": ""
      },
      {
        "text": "signal(SIGINT, SIG_IGN);",
        "image": ""
      },
      {
        "text": "Non è possibile essere immuni al CTRL+C",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La combinazione CTRL+C genera il segnale SIGINT. Impostare la disposition a `SIG_IGN` tramite `signal()` ignora il segnale, impedendo l'azione predefinita di terminazione. `SIG_DFL` invece ripristinerebbe il comportamento default (terminazione).",
    "hint": "Considera quale segnale corrisponde a CTRL+C e quale costante di disposition ignora il segnale anziché ripristinare il comportamento predefinito."
  },
  {
    "question": "Quale dei seguenti comandi scrive una singola riga che consiste nel solo carattere '? ",
    "options": [
      {
        "text": "echo \"'\"| awk '{print \"'\";}'",
        "image": ""
      },
      {
        "text": "echo niente | awk '{print \"'\"'\"' \";}'",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      },
      {
        "text": "echo niente | awk '{print \"'\"'\"'\";}'",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La sequenza '\"'\"'\" permette di inserire un apice singolo all'interno di una stringa shell delimitata da apici singoli: si chiude il quoting con ', si inserisce l'apice protetto da doppi apici \"'\", e si riapre il quoting con '. Awk riceve quindi {print \"'\"} che stampa solo il carattere richiesto.",
    "hint": "Ricorda come si 'rompe' una stringa single-quoted in shell per inserire un carattere single-quote."
  },
  {
    "question": "Nell'albero di directory radicato nella directory corrente di una shell bash ci sono molteplici file di testo, ognuno dei quali contiene il log di una esecuzione di un comando. La prima riga di ogni log riporta esattamente il comando usato per ottenere il log stesso, opzioni ed argomenti compresi. Volendo sapere quali sono i diversi comandi (opzioni ed argomenti esclusi; il comando non contiene mai spazi ed è sempre all'inizio della riga) usati nei vari file di log, quale dei seguenti comandi bash è sbagliato? ",
    "options": [
      {
        "text": "awk 'FNR == 1{print $1}' `find . -type f` | sort | uniq",
        "image": ""
      },
      {
        "text": "for file in `find . -type f`; do awk 'FNR == 1{print $1}' $file; done | sort | uniq",
        "image": ""
      },
      {
        "text": "for file in `find . -type f`; do head -1 $file | awk '{print $1}' | sort | uniq; done",
        "image": ""
      },
      {
        "text": "for file in `find . -type f`; do head -1 $file | awk '{print $1}'; done | sort | uniq",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Inserire sort | uniq dentro il ciclo for processa ogni file singolarmente, impedendo di trovare i comandi unici tra tutti i file. Le altre opzioni applicano sort | uniq all'output aggregato di tutti i file, che è l'approccio corretto.",
    "hint": "Pensa a quando devi eliminare i duplicati: prima unisci tutti i dati o dopo ogni singolo file?"
  },
  {
    "question": "Quale dei seguenti comandi Bash permette di scrivere il numero di caratteri di ogni singola riga di un file di testo nomefile?",
    "options": [
      {
        "text": "for riga in \"`cat nomefile`\"; do echo $riga | wc -c; done",
        "image": ""
      },
      {
        "text": "var=$(cat nomefile); for riga in ${var}; do echo $riga | wc -c; done",
        "image": ""
      },
      {
        "text": "for riga in `cat nomefile`; do echo $riga | wc -c; done",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Tutte le opzioni falliscono perché non gestiscono correttamente l'IFS (Internal Field Separator): A, B e C effettuano word splitting sugli spazi e tabulazioni, perdendo la struttura per-riga. Per processare righe serve while read o IFS= con read, non un for su cat.",
    "hint": "Considera come bash divide le parole quando espande variabili o backticks senza doppi apici."
  },
  {
    "question": "Quale delle seguenti affermazioni sul Linguaggio C è vera?",
    "options": [
      {
        "text": "Richiede che i programmi siano sempre scritti in file con estensione .c",
        "image": ""
      },
      {
        "text": "Richiede che ogni modulo sia scritto in un file separato, come nel Java",
        "image": ""
      },
      {
        "text": "È un linguaggio interpretato",
        "image": ""
      },
      {
        "text": "È un linguaggio compilato",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il C è un linguaggio compilato: il codice sorgente viene tradotto in linguaggio macchina da un compilatore (come gcc) prima dell'esecuzione. Non è interpretato, non richiede estensioni specifiche (anche se .c è convenzionale), e non impone una struttura modulare rigida come Java.",
    "hint": "Distingui tra linguaggi dove il codice viene tradotto prima dell'esecuzione versus quelli eseguiti riga per riga."
  },
  {
    "question": "Quale delle seguenti affermazioni sul Linguaggio C è vera?",
    "options": [
      {
        "text": "Richiede che i programmi siano sempre scritti in file con estensione .c",
        "image": ""
      },
      {
        "text": "È incompatibile con i Sistemi Operativi della famiglia Windows",
        "image": ""
      },
      {
        "text": "È un linguaggio non strutturato e compilato",
        "image": ""
      },
      {
        "text": "È un linguaggio strutturato e compilato",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il C supporta la programmazione strutturata (blocchi, funzioni, controllo di flusso) ed è compilato. Non richiede estensioni .c obbligatorie ed è perfettamente compatibile con Windows tramite compilatori come MinGW o MSVC.",
    "hint": "Valuta le caratteristiche strutturali del C rispetto ai linguaggi non strutturati come l'assembly."
  },
  {
    "question": "Si supponga di voler trovare tutti i link simbolici presenti nell'intero file system, che siano stati acceduti nell'ultimo giorno, e si supponga di volerli spostare nella directory /tmp. Quale dei seguenti comandi realizza tale specifica?",
    "options": [
      {
        "text": "find/ -type l -atime 0 -exec mv '{}' /tmp/ \\;",
        "image": ""
      },
      {
        "text": "find/ -type l -ctime 0 | aw k '{print \"mv\", $1, \"/tmp\";}'",
        "image": ""
      },
      {
        "text": "find/ -type l -atime 0 -exec mv /tmp/ '{}'';'",
        "image": ""
      },
      {
        "text": "find/ -type l -ctime 0 -exec mv '{}' /tmp/ \\;",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'opzione -type l filtra i link simbolici, -atime 0 seleziona i file accessi nelle ultime 24 ore, e -exec permette di eseguire mv per ogni risultato trovato, con {} che rappresenta il nome del file e \\; che termina il comando.",
    "hint": "Controlla la differenza tra tempo di accesso (-atime) e tempo di modifica dei metadati (-ctime), e verifica la sintassi corretta del comando -exec in find."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall dei processi in Linux è falsa?",
    "options": [
      {
        "text": "La syscall getuid() ritorna il real user ID del processo chiamante",
        "image": ""
      },
      {
        "text": "La syscall getpid() ritorna il PID del processo chiamante",
        "image": ""
      },
      {
        "text": "La syscall getppid() ritorna il PID del processo che ha generato quello chiamante (o che lo ha adottato)",
        "image": ""
      },
      {
        "text": "La syscall setuid() ritorna il real user ID del processo chiamante",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "La syscall setuid() serve per modificare l'user ID effettivo del processo (e potenzialmente il saved set-user-ID), non per leggerlo. Restituisce 0 in caso di successo o -1 in caso di errore, mentre è getuid() che restituisce il real UID.",
    "hint": "Ricorda la differenza tra syscall che 'get' (leggono) e syscall che 'set' (impostano) i privilegi di un processo."
  },
  {
    "question": "Si supponga che l'utente nomeutente voglia terminare forzatamente tutti i processi attualmente in esecuzione che lui stesso abbia creato con il comando bash cmd (senza argomenti). Si supponga anche che la stringa cmd non contenga metacaratteri per regular expressions estese. Quale dei seguenti comandi bash deve usare l'utente nomeutente?",
    "options": [
      {
        "text": "kill -9 `ps -unomeutente -opid,cmd | grep -E '^[0-9]+ cmd$' | awk '{print $1}'`",
        "image": ""
      },
      {
        "text": "kill -9 `ps -unomeutente -opid,cmd | grep -E '^[0-9]+ cmd$'`",
        "image": ""
      },
      {
        "text": "kill -9 `ps -unomeutente -opid,cmd | grep -E 'cmd' | awk '{print $1}'`",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il comando ps elenca i processi con PID e comando, grep filtra esattamente le righe con il pattern 'numero cmd' (inizio e fine riga), e awk estrae solo il primo campo (PID) da passare a kill -9 per terminare i processi.",
    "hint": "Verifica cosa succederebbe se passassi a kill non solo il numero PID ma anche il nome del comando, e considera l'importanza di ancorare il pattern di grep a inizio e fine riga."
  },
  {
    "question": "Quale delle seguenti affermazioni sui programmi scritti in Linguaggio C è vera?",
    "options": [
      {
        "text": "Il carattere di fine stringa è essenziale nel caso in cui si passi una stringa alla syscall write su una pipe",
        "image": ""
      },
      {
        "text": "Il carattere di fine stringa è essenziale nel caso in cui si passi una stringa alla funzione printf con specificatore di conversione %s",
        "image": ""
      },
      {
        "text": "Le variabili di tipo char *, se inizializzate a tempo di dichiarazione con una costante stringa, avranno un byte in più costituito dal carattere '0'",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "La funzione printf con lo specificatore %s si aspetta una stringa terminata dal carattere nullo '\\0' per determinare dove finisce la stampa; senza di esso continuerebbe a leggere memoria indefinitamente. La syscall write invece richiede esplicitamente la lunghezza, ignorando eventuali terminatori.",
    "hint": "Considera la differenza tra funzioni di libreria C che gestiscono stringhe (che si basano sul terminatore nullo) e syscall di sistema che operano su buffer di byte con lunghezza esplicita."
  },
  {
    "question": "Esiste in Linux un comando che consente, sfruttando opportunamente le sue opzioni, di stampare il numero di occorrenze consecutive di una riga in un file?",
    "options": [
      {
        "text": "No, occorre utilizzare congiuntamente i comandi grep e wc (con opportune opzioni)",
        "image": ""
      },
      {
        "text": "No, occorre utilizzare congiuntamente i comandi sort e wc (con opportune opzioni)",
        "image": ""
      },
      {
        "text": "Si",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Il comando uniq con l'opzione -c (count) stampa il numero di occorrenze consecutive per ogni riga duplicata in un file, preceduto da un contatore numerico.",
    "hint": "Pensa al comando che rimuove o conta le righe duplicate adiacenti in un file di testo."
  },
  {
    "question": "Quale delle seguenti affermazioni su un file in un filesystem Linux è vera?",
    "options": [
      {
        "text": "Può esistere un solo path, detto assoluto, che permette di richiedere l'accesso a tale file",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Può esistere un solo path relativo che permette di richiedere l'accesso a tale file",
        "image": ""
      },
      {
        "text": "Possono esistere uno o più path assoluti che permettono di richiedere l'accesso a tale file",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il path assoluto rappresenta la posizione di un file a partire dalla directory root in modo univoco e indipendente dalla directory di lavoro corrente, a differenza dei path relativi che variano in base al contesto.",
    "hint": "Confronta la natura dei path assoluti (sempre dalla root) con quelli relativi (dipendenti dalla posizione corrente)."
  },
  {
    "question": "Si consideri il seguente programma in codice C:",
    "options": [
      {
        "text": "Se COPIA consiste nell'istruzione memcpy(p[1], p[0], sizeof(struct s));, allora le istruzioni seguenti (se eseguite) avranno un effetto non predicibile",
        "image": ""
      },
      {
        "text": "Se COPIA consiste nell'assegnamento p[1] = p[0];, allora l'ultima istruzione scriverà  c0ao c0ao c0ao c0ao",
        "image": ""
      },
      {
        "text": "Se COPIA consiste nell'assegnamento p[0] = p[1];, allora l'ultima istruzione scriverà  c0ao ciao ciao ciao",
        "image": ""
      },
      {
        "text": "Se COPIA consiste nell'assegnamento p[1] = p[0];, allora le istruzioni seguenti (se eseguite) avranno un effetto non predicibile",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "#include <string.h>\n        #include <stdlib.h>\n        #include <stdio.h>\n        \n        int main() {\n          struct s {\n            char *a;\n            char b[20];\n          } *p[2];\n          char *a = strdup(\"ciao\");\n          p[0] = (struct s*)malloc(sizeof(struct s));\n          p[0]->a = a;\n          strcpy(p[0]->b, a);\n          COPIA\n          a[1] = '0';\n          printf(\"%s %s %s %s\\n\", p[0]->a, p[0]->b, p[1]->a, p[1]->b);\n        }\n",
    "explanation": "L'istruzione memcpy tenta di scrivere i dati all'indirizzo contenuto in p[1], che non è stato inizializzato e contiene un valore casuale (garbage pointer), causando un comportamento indefinito o un segmentation fault.",
    "hint": "Verifica lo stato di inizializzazione di tutti i puntatori nell'array prima di operare dereferenziazione."
  },
  {
    "question": "Si consideri il seguente frammento di codice C, quali tra queste risposte è falsa?",
    "options": [
      {
        "text": "Non è stata allocata la memoria per le 5 aree puntate dai 5 campi a",
        "image": ""
      },
      {
        "text": "È stata allocata la memoria per 5 strutture di tipo struct s sullo heap",
        "image": ""
      },
      {
        "text": "È stata allocata la memoria per 5 strutture di tipo struct s sullo stack delle chiamate",
        "image": ""
      },
      {
        "text": "È stata allocata la memoria per i 100 caratteri dei 5 campi b sullo stack delle chiamate",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "int main() {\n    struct s {\n      char *a;\n      char b[20];\n    } p[5];\n  ...\n  }",
    "explanation": "La dichiarazione di un array di strutture all'interno di una funzione alloca la memoria nello stack (memoria automatica), non nello heap. Inoltre, i puntatori interni non hanno memoria allocata per i dati puntati.",
    "hint": "Distingui tra allocazione automatica (stack) e dinamica (heap), e osserva cosa viene allocato per i puntatori versus i dati puntati."
  },
  {
    "question": "Si supponga di eseguire con successo i seguenti comandi da una shell sulla quale non ci sono job in background:",
    "options": [
      {
        "text": "Entrambi i job lanciati saranno in stato di Stopped",
        "image": ""
      },
      {
        "text": "Eseguendo il comando ps h -oruid -p `jobs -l | awk '{print $2}'` si ottengono 2 numeri diversi",
        "image": ""
      },
      {
        "text": "Eseguendo il comando ps h -opid -p `jobs -l | awk '{print $2}'` si ottengono 2 numeri diversi",
        "image": ""
      },
      {
        "text": "Eseguendo il comando ps h -oeuid -p `jobs -l | awk '{print $2}'` si ottengono 2 numeri diversi",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "sudo cp -a `which cat` .\nsudo chmod u+s cat\n./cat &\ncat &\n",
    "explanation": "Ogni processo ha un PID univoco nel sistema, quindi i due job in background avranno necessariamente identificativi diversi. Gli UID effettivi (euid) invece potrebbero coincidere se l'utente è root, rendendo l'opzione C l'unica sempre vera.",
    "hint": "Ricorda che il PID è unico per ogni processo, mentre gli UID dipendono dal bit setuid e dall'utente esecutore."
  },
  {
    "question": "Un file nomefile contiene il risultato della compilazione di un programma. Il compilatore in questione scrive righe che iniziano con la sola parola 'error' per gli errori veri e propri, e con 'error warning' per i semplici warning (è garantito che la stringa 'error warning' non sia mai all'inizio di una riga contenente un errore vero e proprio). Quale dei seguenti comandi restituisce le sole righe che si riferiscono ad errori veri e propri?",
    "options": [
      {
        "text": "grep -E '^error ([^w]|w[^a]|wa[^r]|war[^n]|warn[^i]|warni[^n]|warnin[^g])'",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      },
      {
        "text": "grep -E '^error' nomefile | grep -v warning",
        "image": ""
      },
      {
        "text": "grep -E '^error [^w][^a][^r][^n][^i][^n][^g]' nomefile",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La pipeline seleziona prima tutte le righe che iniziano con 'error', poi filtra via quelle contenenti 'warning', isolando correttamente gli errori veri. Le espressioni regolari nelle altre opzioni sono troppo rigide o errate nella gestione dei caratteri.",
    "hint": "Pensa a come combinare grep in pipeline per includere un pattern iniziale e poi escludere un sotto-pattern specifico."
  },
  {
    "question": "Quale delle seguenti affermazioni sulle syscall wait e waitpid è falsa?",
    "options": [
      {
        "text": "Se una chiamata wait(&status); ha successo, il valore di status contiene, tra le altre cose, un flag che indica se il processo figlio appena terminato Ã¨ terminato in modo normale",
        "image": ""
      },
      {
        "text": "Se una chiamata wait(&status); ha successo, il valore di status contiene, tra le altre cose, l'exit status del processo figlio appena terminato",
        "image": ""
      },
      {
        "text": "Se una chiamata wait(&status); ha successo, il valore di status contiene, tra le altre cose, il PID del processo figlio appena terminato",
        "image": ""
      },
      {
        "text": "Se una chiamata wait(&status); ha successo, il valore di status contiene, tra le altre cose, un flag che indica se il processo figlio appena terminato è stato ucciso da un segnale",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "La syscall wait() restituisce il PID del processo figlio terminato come valore di ritorno della funzione stessa, mentre il parametro status (passato per riferimento) contiene informazioni codificate sul modo di terminazione (flag di uscita normale, exit status, segnali), non il PID.",
    "hint": "Distingui tra il valore restituito dalla funzione wait() (il PID) e il contenuto della variabile status (informazioni di terminazione)."
  },
  {
    "question": "Si consideri il seguente programma in codice C:",
    "options": [
      {
        "text": "Se COPIA consiste nell'assegnamento p[1] = p[0];, allora l'ultima istruzione scriverà  c0ao c0ao c0ao c0ao",
        "image": ""
      },
      {
        "text": "Se COPIA consiste nell'istruzione memcpy(&p[1], &p[0], sizeof(struct s));, allora l'ultima istruzione scriverà  c0ao ciao c0ao ciao",
        "image": ""
      },
      {
        "text": "Se COPIA consiste nell'assegnamento p[0] = p[1];, allora l'ultima istruzione avrà un effetto non predicibile",
        "image": ""
      },
      {
        "text": "Se COPIA consiste nell'assegnamento p[1] = p[0];, allora l'ultima istruzione scriverà c0ao ciao c0ao ciao",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main() {\n  struct s {\n    char *a;\n    char b[20];\n  } p[2];\n  char *a = strdup(\"ciao\");\n  p[0].a = a;\n  strcpy(p[0].b, a);\n  COPIA\n  a[1] = '0';\n  printf(\"%s %s %s %s\\n\", p[0].a, p[0].b, p[1].a, p[1].b);\n}",
    "explanation": "Quando si assegna p[1] = p[0], si effettua una shallow copy: p[1].a punta alla stessa memoria di p[0].a, mentre p[1].b è una copia indipendente dell'array. Dopo a[1]='0', la stringa puntata da p[0].a e p[1].a diventa 'c0ao', mentre p[0].b e p[1].b mantengono 'ciao' (copiato prima della modifica).",
    "hint": "Ricorda che la shallow copy copia solo il puntatore, non i dati puntati, mentre l'array viene copiato elemento per elemento."
  },
  {
    "question": "La directory corrente di una shell bash contiene N directory non nascoste. In ognuna di queste directory è contenuto un file di testo .txt contenente una sola riga con un numero M, potenzialmente diverso da directory a directory. Inoltre può essere presente un file dati.M.txt. Si vuole sapere quanti sono in totale, tra le varie directory, questi file dati.M.txt, senza scrivere nulla su standard error. Quale dei seguenti comandi bash è corretto?",
    "options": [
      {
        "text": "for dir in ./*; do test -f $dir/dati.`cat $dir/.txt`.txt | wc -l; done",
        "image": ""
      },
      {
        "text": "for dir in ./*; do test -f $dir/dati.`cat $dir/.txt`.txt && echo si; done | wc -l",
        "image": ""
      },
      {
        "text": "for dir in ./*; do test -f $dir/dati.`cat $dir/.txt`.txt || echo no; done | wc -l",
        "image": ""
      },
      {
        "text": "for dir in ./*; do test -f $dir/dati.`cat $dir/.txt`.txt && echo no; done | wc -l",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il ciclo for itera sulle directory; la command substitution `cat $dir/.txt` legge il valore M; test -f verifica l'esistenza del file e, solo se esiste (operatore &&), stampa 'si'. La pipe finale a wc -l conta il numero totale di righe prodotte, corrispondente al numero di file dati.M.txt trovati.",
    "hint": "Analizza il flusso di dati: il ciclo produce output condizionato dall'esistenza del file, e wc -l conta le linee totali prodotte dal ciclo completo."
  },
  {
    "question": "Si supponga di eseguire con successo i seguenti comandi da una shell sulla quale non ci sono job in background: sudo cp -a `which cat` . sudo chmod u+s cat ./cat & cat & Quale delle seguenti affermazioni è falsa?",
    "options": [
      {
        "text": "Entrambi i job lanciati saranno in stato di Stopped",
        "image": ""
      },
      {
        "text": "Eseguendo il comando ps h -oruid -p `jobs -l | awk '{print $2}'` si ottengono 2 numeri diversi",
        "image": ""
      },
      {
        "text": "Eseguendo il comando ps h -oeuid -p `jobs -l | awk '{print $2}'` si ottengono 2 numeri diversi",
        "image": ""
      },
      {
        "text": "Eseguendo il comando ps h -opid -p `jobs -l | awk '{print $2}'` si ottengono 2 numeri diversi",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "Il bit setuid (u+s) su ./cat fa sì che il processo giri con effective UID (euid) root ma real UID (ruid) dell'utente che lo ha lanciato. Il comando cat di sistema gira invece con entrambi gli UID uguali all'utente. Pertanto i real UID dei due job sono identici, mentre gli effective UID differiscono.",
    "hint": "Ricorda la distinzione tra Real UID (chi ha lanciato il processo) e Effective UID (con quali permessi gira), specialmente nel contesto del setuid bit."
  },
  {
    "question": "Si supponga di avere il seguente frammento di codice:",
    "options": [
      {
        "text": "int fd = open(\"file_esistente.txt\",\"O_RDONLY\");\nlseek(fd, -100, SEEK_END);\nlong pos = lseek(fd, 0, SEEK_CUR);",
        "image": ""
      },
      {
        "text": "int fd = open(\"file_esistente.txt\",\"O_RDONLY\");\nlseek(fd, -100, SEEK_END);\nlong pos = lseek(fd, 0, SEEK_END);",
        "image": ""
      },
      {
        "text": "int fd = open(\"file_esistente.txt\",\"O_RDONLY\");\nlseek(fd, -100, SEEK_END);\nlong pos = lseek(fd, -100, SEEK_END);",
        "image": ""
      },
      {
        "text": "int fd = open(\"file_esistente.txt\",\"O_RDONLY\");\nlseek(fd, -100, SEEK_END);\nlong pos = ltell(fd);",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "FILE *stream = fopen(\"file_esistente.txt\",\"r\");\nfseek(stream, -100, SEEK_END);\nlong pos = ftell(stream);",
    "explanation": "La funzione ftell restituisce la posizione corrente del cursore nel file, che corrisponde all'offset in byte dall'inizio. L'equivalente system call lseek utilizza SEEK_CUR con offset 0 per ottenere la stessa informazione, dopo aver posizionato il cursore a -100 byte dalla fine con SEEK_END.",
    "hint": "Ricorda che per ottenere la posizione corrente con lseek si usa offset 0 e SEEK_CUR."
  },
  {
    "question": "Si vuole scrivere un programma equivalente a questo script ",
    "options": [
      {
        "text": "Nessuna delle altre opzioni è corretta",
        "image": ""
      },
      {
        "text": "printf(\"Esecuzione in corso...\");\nexecl(\"/bin/ls\", \"/bin/ls\", \"-la\", \"/\", NULL);\nprintf(\"fatto\\n\");\n",
        "image": ""
      },
      {
        "text": "printf(\"Esecuzione in corso...\");\nexecl(\"/bin/ls\", \"/bin/ls\", \"-la\");\nprintf(\"fatto\\n\");\n",
        "image": ""
      },
      {
        "text": "printf(char **argv = {\"-la\", \"/\", 0};\n\"Esecuzione in corso...\");\nexecl(\"/bin/ls\", \"/bin/ls\", \"-la\", \"/\", NULL);\nprintf(\"fatto\\n\");\n",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "echo -n \"Esecuzione in corso...\"\r\n/bin/ls -la /\r\necho \"fatto\"\r\n",
    "explanation": "Le chiamate execl (e famiglia exec) sostituiscono l'immagine del processo corrente con il nuovo programma: se l'esecuzione ha successo, il controllo non ritorna mai al programma chiamante. Pertanto il printf finale nelle opzioni B, C e D non verrebbe mai eseguito, rendendo nessuna di esse equivalente allo script.",
    "hint": "Considera cosa succede al processo quando execl ha successo."
  },
  {
    "question": "Quale dei seguenti frammenti di codice è corretto?",
    "options": [
      {
        "text": "int pid = fork();\r\nif (pid == 0) {\r\n    /* fai qualcosa, sei il figlio */\r\n}else if (pid > 0) {\r\n    /* fai qualcosa, sei il padre */\r\n}else {\r\n     perror(\"fork failed\");\r\n}\n",
        "image": ""
      },
      {
        "text": "int pid = fork();\r\nif (pid == 0) {\r\n    /* fai qualcosa, sei il padre */\r\n}else if (pid > 0) {\r\n    /* fai qualcosa, sei il figlio */\r\n}else {\r\n     perror(\"fork failed\");\r\n}\n",
        "image": ""
      },
      {
        "text": "Tutte le altre opzioni sono sbagliate",
        "image": ""
      },
      {
        "text": "int pid = fork();\r\nif (pid < 0) {\r\n    /* fai qualcosa, sei il figlio */\r\n}else if (pid > 0) {\r\n    /* fai qualcosa, sei il padre */\r\n}else {\r\n     perror(\"fork failed\");\r\n}\n",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "La system call fork() restituisce 0 nel processo figlio, il PID del figlio (valore positivo) nel processo padre, e -1 in caso di errore. L'opzione A gestisce correttamente questi tre casi per distinguere l'esecuzione tra padre e figlio.",
    "hint": "Chi riceve il valore 0 e chi riceve un numero positivo dopo la fork?"
  },
  {
    "question": "Si supponga di avere il seguente frammento di codice, quale dei seguenti frammenti di codice ha lo stesso effetto?",
    "options": [
      {
        "text": "int var = somefunction1();\r\ndouble var2 = somefunction2();\r\nchar *buf = calloc(sizeof(var2) > sizeof(var)? sizeof(var2) : sizeof(var), sizeof(char));\r\nsprintf(buf, \"%d\\n\", var);\r\nwrite(1, buf, sizeof(var) + 1);\r\nsprintf(buf, \"%lf\\n\", var2);\r\nwrite(1, buf, sizeof(var2) + 1);\r\n",
        "image": ""
      },
      {
        "text": "int var = somefunction1();\r\ndouble var2 = somefunction2();\r\nchar buf[4];\r\nsprintf(buf, \"%d\", var);\r\nwrite(1, buf, sizeof(var));\r\nwrite(1, \"\\n\", 1);\r\nsprintf(buf, \"%lf\", var2);\r\nwrite(1, buf, sizeof(var2));write(1, \"\\n\", 1);\r\n",
        "image": ""
      },
      {
        "text": "int var = somefunction1();\r\ndouble var2 = somefunction2();\r\nwrite(1, (char *)&var, sizeof(var));\r\nwrite(1, (char *)&var2, sizeof(var2));\r\n",
        "image": ""
      },
      {
        "text": "int var = somefunction1();\r\ndouble var2 = somefunction2();\r\nchar *buf = calloc(sizeof(var2) > sizeof(var)? sizeof(var2) : sizeof(var), sizeof(char));\r\nsprintf(buf, \"%d\", var);\r\nwrite(1, buf, sizeof(var));\r\nwrite(1, \"\\n\", 1);\r\nsprintf(buf, \"%lf\", var2);\r\nwrite(1, buf, sizeof(var2));\r\nwrite(1, \"\\n\", 1);\r\n",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "int var = somefunction1();\r\ndouble var2 = somefunction2();\r\nfprintf(stdout, \"%d\\n%lf\\n\", var, var2);\r\n",
    "explanation": "fprintf formatta i dati in stringhe testuali prima di scriverli. L'opzione D replica questo comportamento usando sprintf per convertire i valori in stringhe e write per scriverle su stdout (file descriptor 1), gestendo correttamente i caratteri newline separatamente come nel codice originale.",
    "hint": "Confronta l'output testuale esatto: fprintf scrive caratteri, non dati binari."
  },
  {
    "question": "Si consideri la riga di comando bash while condizione; do comando1 | comando2; done | comando3. Assumendo che condizione, comando1, comando2 e comando3 non contengano errori, quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "Se espressione risulta essere falsa, comando2 viene eseguito almeno una volta",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "Se espressione risulta essere falsa, comando1 viene eseguito almeno una volta",
        "image": ""
      },
      {
        "text": "Se espressione risulta essere falsa, comando3 viene eseguito almeno una volta ",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Il costrutto while...done è un comando completo che può essere inserito in una pipeline. Anche se la condizione è inizialmente falsa e il corpo del ciclo non viene eseguito, il while stesso produce un flusso di output (vuoto) che attraversa la pipe, causando l'esecuzione di comando3.",
    "hint": "La pipe finale collega l'intero ciclo while a comando3, indipendentemente da quante iterazioni vengano eseguite."
  },
  {
    "question": "Si consideri la riga di comando bash if condizione; then comando1; fi. Assumendo che comando1 non contenga errori di sintassi, quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "comando1 viene eseguito solo se condizione scrive 0 su standard output e nulla su standard error",
        "image": ""
      },
      {
        "text": "comando1 viene eseguito solo se condizione scrive 1 su standard output e nulla su standard error",
        "image": ""
      },
      {
        "text": "comando1 viene eseguito solo se condizione scrive 1 su standard error e nulla su standard output",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "In bash, la struttura if valuta il codice di uscita (exit status) del comando condizione, non il suo output su stdout o stderr. Il ramo then viene eseguito solo se il codice di ritorno è 0 (successo), indipendentemente dal contenuto dei flussi standard.",
    "hint": "Ricorda che il shell controlla la variabile $? per decidere se un comando ha avuto successo, non ciò che viene stampato a video."
  },
  {
    "question": "Si supponga che le variabili bash a, b e c abbiano valori, rispettivamente, b, c e 1. Quale delle seguenti affermazioni è vera?",
    "options": [
      {
        "text": "L'espansione aritmetica di a è 1",
        "image": ""
      },
      {
        "text": "Nessuna delle altre opzioni è vera",
        "image": ""
      },
      {
        "text": "L'espansione standard di a è 1",
        "image": ""
      },
      {
        "text": "La variabile a viene sempre espansa ad 1",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "L'espansione aritmetica $((a)) risolve ricorsivamente i nomi delle variabili fino a ottenere un valore numerico: a contiene 'b', b contiene 'c', e c contiene '1', quindi il risultato finale è 1. L'espansione standard $a restituirebbe invece semplicemente la stringa 'b'.",
    "hint": "Pensa a come la shell risolve le variabili quando si trova all'interno di un contesto aritmetico con doppie parentesi."
  },
  {
    "question": "Quale delle seguenti affermazioni sul comando top è vera?",
    "options": [
      {
        "text": "Nessuna delle altre affermazioni è vera",
        "image": ""
      },
      {
        "text": "Senza argomenti, il suo output è uguale a quello di ps senza argomenti",
        "image": ""
      },
      {
        "text": "Se lanciato con la riga di comando top, per terminarlo è necessario premere CTRL + C",
        "image": ""
      },
      {
        "text": "Se lanciato con la riga di comando top - b, per terminarlo è sufficiente premere il tasto Q",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "",
    "explanation": "Il comando top è un visualizzatore interattivo che si aggiorna continuamente, a differenza di ps che è statico. Si termina premendo 'q', mentre CTRL+C invia un segnale di interruzione; la modalità batch (-b) è non-interattiva e non risponde al tasto 'q'.",
    "hint": "Distingui tra modalità interattiva e batch, e considera come vengono gestiti i segnali di terminazione rispetto ai comandi interni del programma."
  },
  {
    "question": "Si supponga di voler inizializzare una variabile var1 di una shell bash in modo tale che sia il contenuto del file filename.txt se tale file esiste, ed il valore della variabile var2 altrimenti. Quale dei seguenti comandi realizza correttamente quanto sopra ? ",
    "options": [
      {
        "text": "var1=`echo filename.txt 2> /dev/null || cat $var2`",
        "image": ""
      },
      {
        "text": "var1=`cat filename.txt 2> /dev/null || echo $var2`",
        "image": ""
      },
      {
        "text": "var1=`cat filename.txt > /dev/null || echo $var2`",
        "image": ""
      },
      {
        "text": "var1=`cat filename.txt 2> /dev/null && echo $var2`",
        "image": ""
      }
    ],
    "correctIndex": 1,
    "image": "",
    "code": "",
    "explanation": "L'operatore || esegue il secondo comando solo se il primo fallisce (exit code non zero). Redirigendo stderr (2>) su /dev/null si sopprimono gli errori se il file non esiste, permettendo a cat di fallire silenziosamente e attivare l'alternativa echo $var2.",
    "hint": "Osserva la differenza tra la redirezione dello standard error (2>) e quello standard (>), e il comportamento degli operatori logici || versus &&."
  },
  {
    "question": "Il comando ssh hostname cmd esegue il comando cmd sulla bash della macchina remota hostname, dopo aver richiesto l'immissione della password per l'utente corrente. Supponendo che la fase di connessione e di immissione della password vada a buon fine, quale delle seguenti affermazioni è falsa?",
    "options": [
      {
        "text": "Il comando ssh hostname 'ls '| wc -l esegue sia ls che wc su hostname",
        "image": ""
      },
      {
        "text": "Il comando ssh hostname ls \\| wc -l esegue sia ls che wc su hostname",
        "image": ""
      },
      {
        "text": "Il comando ssh hostname ls | wc -l esegue ls su hostname, e wc sulla macchina attuale",
        "image": ""
      },
      {
        "text": "Il comando ssh hostname ls '|' wc -l esegue sia ls che wc su hostname",
        "image": ""
      }
    ],
    "correctIndex": 2,
    "image": "",
    "code": "",
    "explanation": "Quando la pipe non è quotata o protetta, la shell locale la interpreta prima di eseguire ssh. Quindi ssh esegue solo ls sul host remoto, mentre wc -l viene eseguito localmente ricevendo l'output di ssh via pipe. Le altre opzioni con quoting o escaping fanno eseguire entrambi i comandi sul remoto.",
    "hint": "Considera quali metacaratteri vengono interpretati dalla shell locale prima dell'esecuzione di ssh e quali vengono invece passati all'host remoto."
  },
  {
    "question": "Si supponga di avere il seguente frammento di codice, e che  il file file_esistente.txt abbia il seguente contenuto (comprensivo di 2 caratteri carriage return) 4567 34.56",
    "options": [
      {
        "text": "int fd = open(\"file_esistente.txt\", O_RDONLY);\r\nint var;\r\ndouble var2;\r\nchar buf[4];\r\nread(fd, buf, sizeof(var));\r\nvar = atoi(buf);\r\nread(fd, buf, sizeof(var2));\r\nvar2 = atof(buf);",
        "image": ""
      },
      {
        "text": "int fd = open(\"file_esistente.txt\", O_RDONLY);\r\nint var;\r\ndouble var2;\r\nread(fd, &var, sizeof(var));\r\nread(fd, &var2, sizeof(var2));\r\n",
        "image": ""
      },
      {
        "text": "fd = open(\"file_esistente.txt\", O_RDONLY);\r\nint var;\r\ndouble var2;\r\nchar buf[6];\r\nread(fd, buf, 5);\r\nvar = atoi(buf);\r\nread(fd, buf, 6);\r\nvar2 = atof(buf);",
        "image": ""
      },
      {
        "text": "int fd = open(\"file_esistente.txt\", O_RDONLY);\r\nint var;\r\ndouble var2;\r\nfscanf(fd, \"%d\\n%lf\\n\", &var, &var2);\r\n",
        "image": ""
      }
    ],
    "correctIndex": 0,
    "image": "",
    "code": "FILE *stream = fopen(\"file_esistente.txt\", \"r\");\r\nint var;\r\ndouble var2;\r\nfscanf(stream, \"%d\\n%lf\\n\", &var, &var2);",
    "explanation": "La funzione fscanf legge dati formattati come testo ASCII. Per ottenere lo stesso risultato con read, è necessario leggere i byte in un buffer e convertirli esplicitamente con atoi e atof, poiché read effettua solo trasferimenti binari senza interpretazione del formato. L'opzione B leggerebbe i byte ASCII come rappresentazione binaria dei numeri, mentre la D usa erroneamente un file descriptor con fscanf che richiede un puntatore FILE*.",
    "hint": "Ricorda che read legge byte raw mentre fscanf legge testo formattato, richiedendo conversione esplicita per simularne il comportamento."
  },
  {
    "question": "Ignorando eventuali memory leaks, quale dei seguenti frammenti di codice può portare ad un segmentation fault?",
    "options": [
      {
        "text": "char * p = malloc(10 * sizeof(char)); \r\np[1]='a';\r\nfree(p)",
        "image": ""
      },
      {
        "text": "char * p = malloc(10 * sizeof(char)); \r\np[9]='a';\r\np = NULL;\r\np=realloc(p, 10*sizeof(char));\r\nfree(p)",
        "image": ""
      },
      {
        "text": "char * p = calloc(10, sizeof(char)); \r\np[9]='a';\r\np=realloc(p, 10*sizeof(char));\r\nfree(p)",
        "image": ""
      },
      {
        "text": "char * p = calloc(10, sizeof(char)); \r\np[9]='a';\r\nfree(p)\r\np=realloc(p, 10*sizeof(char));\r\nfree(p)",
        "image": ""
      }
    ],
    "correctIndex": 3,
    "image": "",
    "code": "",
    "explanation": "Dopo free(p), il puntatore diventa dangling. Invocare realloc su un puntatore già liberato costituisce un errore di use-after-free, che causa undefined behavior e tipicamente un segmentation fault poiché il gestore della memoria tenta di accedere a metadati dell'heap invalidi.",
    "hint": "Verifica la sequenza delle operazioni: cosa succede se tenti di riallocare un puntatore che hai appena rilasciato?"
  }
]