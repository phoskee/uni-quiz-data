[
  {
    "question": "La Macchina di Turing e la Macchina di Von Neuman sono:",
    "options": [
      {
        "text": "Computer che non vengono più venduti",
        "image": null
      },
      {
        "text": "Modelli di computer che risolvono specifici problemi matematici",
        "image": null
      },
      {
        "text": "Computer di marca diversa",
        "image": null
      },
      {
        "text": "Modelli teorici di computazione algoritmica",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Entrambe sono modelli astratti e teorici piuttosto che macchine fisiche. La Macchina di Turing definisce formalmente i limiti della computabilità, mentre l'architettura di Von Neumann descrive il modello stored-program dei computer moderni.",
    "hint": "Considera la differenza tra un modello concettuale matematico e un prodotto commerciale."
  },
  {
    "question": "I problemi che possono essere risolti con un algoritmo sono:",
    "options": [
      {
        "text": "Tutti i problemi",
        "image": null
      },
      {
        "text": "Solo i problemi con meno di un miliardo di dati",
        "image": null
      },
      {
        "text": "Solo i problemi con soluzione numerica",
        "image": null
      },
      {
        "text": "Un sottoinsieme di tutti i problemi",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "La teoria della calcolabilità dimostra che esistono problemi indecidibili (come l'Halting Problem) per i quali non esiste alcun algoritmo risolutivo. I problemi algoritmicamente risolvibili costituiscono quindi un sottoinsieme proprio di tutti i problemi matematici.",
    "hint": "Pensa ai limiti teorici della computazione dimostrati da Turing e Church."
  },
  {
    "question": "Rispetto alla Macchina di Turing la Macchina di Von Neuman risolve:",
    "options": [
      {
        "text": "Un numero di problemi minore",
        "image": null
      },
      {
        "text": "Gli stessi problemi",
        "image": null
      },
      {
        "text": "Un numero di problemi maggiore",
        "image": null
      },
      {
        "text": "Solo i problemi con soluzione numerica",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "L'architettura di Von Neumann è una realizzazione pratica della macchina universale di Turing; entrambi i modelli sono Turing-completi e possono calcolare esattamente le stesse funzioni, ovvero quelle calcolabili effettivamente.",
    "hint": "Rifletti sul concetto di equivalenza computazionale e Turing-completezza."
  },
  {
    "question": "In ogni transizioni di stato della Macchina di Turing lo stato successivo dipende:",
    "options": [
      {
        "text": "Dalla lunghezza della sequenza scritta sul nastro",
        "image": null
      },
      {
        "text": "Dallo stato attuale e dal simbolo letto sul nasto",
        "image": null
      },
      {
        "text": "Dal primo stato assunto dalla macchina",
        "image": null
      },
      {
        "text": "Dal numero totale degli stati",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "La funzione di transizione δ di una MdT è definita formalmente come δ: Q × Γ → Q × Γ × {L,R}, dove Q è l'insieme degli stati e Γ l'alfabeto del nastro. La transizione dipende quindi solo dalla coppia (stato corrente, simbolo letto).",
    "hint": "Ricorda la definizione matematica della funzione di transizione in una macchina a stati finiti con nastro."
  },
  {
    "question": "Il Sistema Operativo è un programma che:",
    "options": [
      {
        "text": "Traduce un programma scritto in un Linguaggio ad Alto Livello in un programma in Linguaggio Macchina",
        "image": null
      },
      {
        "text": "Esegue le operazioni aritmetiche e logiche",
        "image": null
      },
      {
        "text": "Gestisce le risorse Hardware del computer assegnandole ai programmi da eseguire e l'interazione con l'utente",
        "image": null
      },
      {
        "text": "Valuta le prestazioni dell'Unità Aritmetico-Logica",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Il Sistema Operativo funge da intermediario tra hardware e software applicativo, gestendo l'allocazione delle risorse (CPU, memoria, dispositivi I/O), la multiprogrammazione e fornendo le system call per l'interazione con l'utente.",
    "hint": "Distingui il ruolo del SO da quello del compilatore o dell'unità aritmetica."
  },
  {
    "question": "Le componenti Hardware del computer comunicano tra loro utilizzando:",
    "options": [
      {
        "text": "La Memoria",
        "image": null
      },
      {
        "text": "Canali di comunicazione detti bus",
        "image": null
      },
      {
        "text": "Il Clock in fissati intervalli di tempo",
        "image": null
      },
      {
        "text": "Il Compilatore",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "I bus sono canali fisici (fili o tracce sul circuito) che permettono il trasferimento di dati, indirizzi e segnali di controllo tra CPU, memoria e periferiche. Rappresentano l'infrastruttura di interconnessione dell'architettura hardware.",
    "hint": "Pensa ai 'collegamenti fisici' sul motherboard che trasportano dati e segnali."
  },
  {
    "question": "La valutazione delle prestazioni di un computer misura:",
    "options": [
      {
        "text": "I costi del Software",
        "image": null
      },
      {
        "text": "I costi dell'Hardware",
        "image": null
      },
      {
        "text": "La correttezza della soluzione fornita da un programma",
        "image": null
      },
      {
        "text": "L'efficienza della esecuzione di un programma su un computer",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "La valutazione delle prestazioni (performance) si concentra su metriche temporali e di throughput, come il tempo di esecuzione o le istruzioni per secondo, misurando quanto efficientemente un programma viene eseguito su una specifica architettura.",
    "hint": "Considera cosa misurano termini come 'velocità di esecuzione' o 'throughput'."
  },
  {
    "question": "Un algoritmo è:",
    "options": [
      {
        "text": "Una lista anche infinita di azioni comprensibili ed eseguibili da una macchina",
        "image": null
      },
      {
        "text": "Una lista finita di azioni comprensibili ed eseguibili da una macchina",
        "image": null
      },
      {
        "text": "Un insieme di azioni comprensibili ed eseguibili da una macchina",
        "image": null
      },
      {
        "text": "Una lista di azioni senza particolari vincoli",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Per definizione formale, un algoritmo deve essere composto da un numero finito di passi elementari, eseguibili e non ambigui, che portano a una soluzione in tempo finito. La finitezza è essenziale per garantire la terminazione.",
    "hint": "Ricorda che un algoritmo deve sempre terminare dopo un numero finito di passi."
  },
  {
    "question": "I progressi della tecnologia hanno:",
    "options": [
      {
        "text": "Migliorato le prestazioni ed aumentatol'insieme dei problemi algoritmicamente risolubili",
        "image": null
      },
      {
        "text": "Ridotto i costi ed aumentato l'insieme dei problemi algoritmicamente risolubili",
        "image": null
      },
      {
        "text": "Cambiato i risultati teorici relativi alla computazione algoritmica",
        "image": null
      },
      {
        "text": "Migliorato le prestazioni del computer ma non hanno cambiato l'insieme dei problemi algoritmicamente risolubili",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "I progressi tecnologici migliorano la velocità di calcolo e la capacità di memoria, ma non alterano i confini teorici della calcolabilità stabiliti dalla Tesi di Church-Turing. I problemi indecidibili restano tali indipendentemente dall'hardware.",
    "hint": "Distingui tra miglioramenti pratici (velocità) e limiti teorici della computabilità."
  },
  {
    "question": "Nella Macchina di Turing gli stati, le trasizioni di stato, i simboli dell'alfabeto, i caratteri della sequenza scritta sul nastro sono:",
    "options": [
      {
        "text": "Insiemi infiniti nel caso di algoritmi risolutivi di problemi complessi",
        "image": null
      },
      {
        "text": "Insiemi sia finiti che infiniti",
        "image": null
      },
      {
        "text": "Insiemi comunque grandi, ma sempre finiti",
        "image": null
      },
      {
        "text": "Sempre insiemi infiniti",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Nella definizione formale di Macchina di Turing, l'insieme degli stati, l'alfabeto di input e l'insieme delle transizioni sono definiti come insiemi finiti, anche se potenzialmente molto grandi. Solo il nastro è potenzialmente infinito.",
    "hint": "Rifletti su quali elementi sono definiti 'a priori' nella specifica della macchina rispetto al nastro."
  },
  {
    "question": "Una Architettura RISC è caratterizzata da:",
    "options": [
      {
        "text": "Istruzioni in Linguaggio Macchina più semplici ed un Hardware meno complesso",
        "image": null
      },
      {
        "text": "Istruzioni in Linguaggio Macchina che si possono eseguire su un qualunque computer",
        "image": null
      },
      {
        "text": "Istruzioni in Linguaggio Macchina più numerose ed un Hardware più complesso",
        "image": null
      },
      {
        "text": "Istruzioni in Linguaggio Macchina più lente ed un Hardware più complesso",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "L'architettura RISC (Reduced Instruction Set Computer) è progettata per eseguire un numero ridotto di istruzioni semplici e veloci, permettendo un'implementazione hardware più semplice con unità di controllo cablate piuttosto che microprogrammate, a differenza delle architetture CISC.",
    "hint": "Rifletti sul significato dell'acronimo 'Reduced' e confronta la complessità hardware con le architetture CISC."
  },
  {
    "question": "Una istruzione in Linguaggio Macchina del MIPS è rappresentata da:",
    "options": [
      {
        "text": "Una sequenza di 32 simboli dell'alfabero inglese",
        "image": null
      },
      {
        "text": "Una sequenza di almeno 32 cifre binarie",
        "image": null
      },
      {
        "text": "Una sequenza di 32 cifre binarie",
        "image": null
      },
      {
        "text": "Una sequenza di cifre binarie di lunghezza variabile",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Il MIPS adotta un formato a lunghezza fissa dove ogni istruzione occupa esattamente 32 bit (4 byte), semplificando il fetch e la decodifica delle istruzioni nella pipeline, coerentemente con la filosofia RISC della regolarità.",
    "hint": "Ricorda che l'architettura MIPS è a 32 bit e utilizza istruzioni di lunghezza costante."
  },
  {
    "question": "L'Assembler è:",
    "options": [
      {
        "text": "Un programma che traduce un programma scritto in Assembly in un programma scritto in Linguaggio Macchina",
        "image": null
      },
      {
        "text": "Un linguaggio di programmazione",
        "image": null
      },
      {
        "text": "Un programma che traduce un programma scritto in un Linguaggio ad Alto Livello in un programma scritto in Linguaggio Macchina",
        "image": null
      },
      {
        "text": "Un programma che traduce un programma scritto in Linguaggio Macchina in un programma scritto in Assembly",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "L'Assembler è un traduttore specifico che converte il linguaggio Assembly (mnemonici testuali leggibili) nel corrispondente linguaggio macchina (codice binario eseguibile dalla CPU), distinguendosi dal compilatore che traduce linguaggi ad alto livello.",
    "hint": "Distingui tra il traduttore specifico per il linguaggio simbolico dei processori e quello per linguaggi di programmazione ad alto livello."
  },
  {
    "question": "Per accedere al contenuto di un particolare registro è necessario conoscere:",
    "options": [
      {
        "text": "La lunghezza di tale registro",
        "image": null
      },
      {
        "text": "Il tipo di dato scritto in tale registro",
        "image": null
      },
      {
        "text": "L'indirizzo scritto in tale registro",
        "image": null
      },
      {
        "text": "L'indirizzo di tale registro",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "I registri del processore sono organizzati in un banco di registri (register file) accessibile tramite indirizzi numerici specifici; per leggere o modificare il contenuto di un registro, il processore deve prima selezionarlo tramite il suo indirizzo univoco.",
    "hint": "Considera come il processore selezioni uno specifico registro tra i 32 disponibili nel MIPS."
  },
  {
    "question": "Nel Linguaggio Assembly del MIPS il simbolo $ seguito da caratteri alfanumerici rappresenta:",
    "options": [
      {
        "text": "Il contenuto di un registro del processore",
        "image": null
      },
      {
        "text": "Il valore dell'operando di una istruzione",
        "image": null
      },
      {
        "text": "L'indirizzo di un registro del processore",
        "image": null
      },
      {
        "text": "La sequenza di 32 bit che fornisce l'operando di una istruzione",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "In MIPS Assembly, la notazione con il simbolo $ (es. $t0, $s0) rappresenta l'indirizzo o il numero identificativo del registro nel banco registri, che l'assemblatore traduce nel corrispondente campo di 5 bit nell'istruzione macchina.",
    "hint": "Pensa alla differenza tra l'identificativo del registro (il suo 'indirizzo' nel register file) e il valore contenuto al suo interno."
  },
  {
    "question": "In un registro del Processore MIPS si può memorizzare:",
    "options": [
      {
        "text": "Una sequenza di più di 32 cifre binarie",
        "image": null
      },
      {
        "text": "Una sequenzadi 32 simboli dell'alfabero inglese",
        "image": null
      },
      {
        "text": "Una sequenza di cifre binarie di lunghezza variabile",
        "image": null
      },
      {
        "text": "Una sequenza di 32 cifre binarie",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'architettura MIPS è a 32 bit, quindi ogni registro contiene esattamente 32 bit (cifre binarie). La dimensione è fissa e non può contenere simboli testuali direttamente come entità atomiche.",
    "hint": "Ricorda che il MIPS è un'architettura a 32 bit e i registri hanno dimensione fissa."
  },
  {
    "question": "Un programma scritto in un Linguaggio ad Alto Livello ed uno scritto in Assembly possono essere eseguiti:",
    "options": [
      {
        "text": "Il primo solo su un computer con l'Architettura corrispondente al Linguaggio ad Alto Livello il secondo su un qualunque computer",
        "image": null
      },
      {
        "text": "Entrambi solo su un computer con Architettura corrispondente all'Assembly",
        "image": null
      },
      {
        "text": "Il primo su un qualunque computer il secondo solo su un computer con Architettura corrispondente all'Assembly",
        "image": null
      },
      {
        "text": "Entrambi su un qualunque computer",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "I linguaggi ad alto livello sono portabili grazie ai compilatori/interpreteri che li adattano a diverse architetture, mentre l'Assembly è specifico dell'ISA (Instruction Set Architecture) del processore e usa mnemoniche che corrispondono direttamente alle istruzioni macchina di quella specifica CPU.",
    "hint": "Considera la differenza tra portabilità del software e dipendenza dall'hardware specifico."
  },
  {
    "question": "Una istruzione Assembly corrisponde sempre a:",
    "options": [
      {
        "text": "Più istruzioni in Linguaggio Macchina",
        "image": null
      },
      {
        "text": "Una sola istruzione in Linguaggio Macchina",
        "image": null
      },
      {
        "text": "Una sola istruzione in Linguaggio ad Alto Livello",
        "image": null
      },
      {
        "text": "Più istruzioni in Linguaggio ad Alto Livello",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "L'Assembly è un linguaggio simbolico che rappresenta direttamente le istruzioni macchina in formato leggibile, mantenendo una corrispondenza biunivoca (1:1) con il codice binario eseguito dal processore.",
    "hint": "L'Assembly è essenzialmente una rappresentazione testuale delle istruzioni binarie."
  },
  {
    "question": "I registri del Processore MIPS con indirizzi da $t0 a $t9 e da $s0 a $s7 sono utilizzati per:",
    "options": [
      {
        "text": "Memorizzare sequenze di 32 bit che rappresentano gli indirizzi degli operandi delle istruzioni",
        "image": null
      },
      {
        "text": "Gestire la chiamata di procedura",
        "image": null
      },
      {
        "text": "Gestire le funzioni svolte dal Software di Sistema",
        "image": null
      },
      {
        "text": "Memorizzare sequenze di 32 bit che rappresentano il valore degli operandi delle istruzioni",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "I registri $t (temporanei) e $s (salvati) sono registri general purpose a 32 bit utilizzati per memorizzare operandi e risultati intermedi durante l'esecuzione dei programmi utente, non per gestire lo stack o le chiamate a funzione (compito di altri registri come $sp e $ra).",
    "hint": "Pensa a quali registri usa un programma normale per fare calcoli con variabili."
  },
  {
    "question": "Gli indirizzi dei registri del Processore MIPS sono:",
    "options": [
      {
        "text": "Sequenze binarie contenute nei registri del processore",
        "image": null
      },
      {
        "text": "I 32 numeri numeri da 1 a 32",
        "image": null
      },
      {
        "text": "I 32 numeri da 0 a 31",
        "image": null
      },
      {
        "text": "Sequenze binarie fornite da dispositivi esterni",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Il MIPS possiede 32 registri general purpose, identificati numericamente da 0 a 31 (codificabili con 5 bit), ai quali corrispondono nomi simbolici come $zero, $t0, $s0, ecc.",
    "hint": "Quanti registri general purpose ha il MIPS e qual è il primo numero di indice in informatica?"
  },
  {
    "question": "La Sintassi di un Linguaggio Formale stabilisce:",
    "options": [
      {
        "text": "Il significato dell'istruzione",
        "image": null
      },
      {
        "text": "Le regole per rappresentare i numeri con segno",
        "image": null
      },
      {
        "text": "Le regole per scrivere ogni istruzione del Linguaggio Formale in modo corretto",
        "image": null
      },
      {
        "text": "Le regole per eseguire l'istruzione",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "La sintassi definisce le regole grammaticali e strutturali che determinano quali sequenze di simboli costituiscono programmi ben formati, distinguendosi dalla semantica che invece riguarda il significato (opzione A) e dalla semantica operazionale che riguarda l'esecuzione (opzione D).",
    "hint": "Pensa alla differenza tra la forma corretta di una frase e il suo significato."
  },
  {
    "question": "La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione max=200; con l'associazione max--> $s5 è:",
    "options": [
      {
        "text": "addi $s5, $s5, 200",
        "image": null
      },
      {
        "text": "add $s5, $zero, 200",
        "image": null
      },
      {
        "text": "sub $s5, $zero, 200",
        "image": null
      },
      {
        "text": "addi $s5, $zero, 200",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Per caricare un valore immediato in un registro si utilizza l'istruzione addi (add immediate) con il registro $zero (che contiene sempre 0) come registro sorgente, sommando effettivamente 200 a 0 e memorizzando il risultato in $s5.",
    "hint": "Considera quale registro MIPS contiene permanentemente il valore zero e quale istruzione permette di usare costanti numeriche direttamente."
  },
  {
    "question": "La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione a=a*2; con l'associazione a--> $s0 è:",
    "options": [
      {
        "text": "addi $s0, $s0, 2",
        "image": null
      },
      {
        "text": "add $s0, $s0, $s0",
        "image": null
      },
      {
        "text": "addi $s0, $s0, $s0",
        "image": null
      },
      {
        "text": "add $s0, $s0, 2",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "La moltiplicazione per 2 equivale all'addizione di un numero con se stesso. Poiché il valore di a si trova in $s0, sommiamo $s0 con $s0 e memorizziamo il risultato in $s0 usando l'istruzione add (non addi, poiché non usiamo un immediato).",
    "hint": "Ricorda che moltiplicare per due è equivalente a sommare una variabile a se stessa."
  },
  {
    "question": "La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione h=b+c; con l'associazione b-->$s5 c-->$s2 h--> $t0 è:",
    "options": [
      {
        "text": "add $s5, $s2, $t0",
        "image": null
      },
      {
        "text": "add $t0, $s5, $s2",
        "image": null
      },
      {
        "text": "add $s2, $s5, $t0",
        "image": null
      },
      {
        "text": "add $t0, $s5, $s0",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "In assembly MIPS, il formato dell'istruzione add è `add destinazione, sorgente1, sorgente2`. Qui $t0 è la destinazione (h), mentre $s5 (b) e $s2 (c) sono i registri sorgente da sommare.",
    "hint": "Ricorda l'ordine degli operandi nelle istruzioni aritmetiche MIPS: prima la destinazione, poi le due sorgenti."
  },
  {
    "question": "Il registro destinazione nell'istruzione add $s2, $t0, $t1 è:",
    "options": [
      {
        "text": "$s2",
        "image": null
      },
      {
        "text": "$t1",
        "image": null
      },
      {
        "text": "$t0",
        "image": null
      },
      {
        "text": "$t2",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "Nella sintassi MIPS per istruzioni di tipo R come add, il primo registro specificato è sempre la destinazione dove viene memorizzato il risultato, mentre il secondo e il terzo sono gli operandi sorgente.",
    "hint": "Nelle istruzioni aritmetiche MIPS, il primo operando dopo il nome dell'istruzione indica dove viene salvato il risultato."
  },
  {
    "question": "Il Codice Operativo di una istruzione aritmetica dell'Assembly stabilisce:",
    "options": [
      {
        "text": "Solo l'operazione aritmetica da eseguire",
        "image": null
      },
      {
        "text": "L'operazione aritmetica da eseguire e come reperire gli operandi",
        "image": null
      },
      {
        "text": "Solo gli operandi dell'operazione aritmetica da eseguire",
        "image": null
      },
      {
        "text": "Solo dove scrivere il risultato dell'operazione dopo l'esecuzione",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Il codice operativo (opcode) definisce non solo l'operazione da eseguire (es. somma o sottrazione), ma anche il formato dell'istruzione (R-type, I-type, etc.), determinando quindi come reperire gli operandi (da registri, immediati o memoria).",
    "hint": "Considera che l'opcode distingue tra istruzioni che usano solo registri e quelle che usano un valore immediato."
  },
  {
    "question": "Nell'istruzione addi dell'Assembly MIPS l'operando costante è contenuto:",
    "options": [
      {
        "text": "Nel registro destinazione",
        "image": null
      },
      {
        "text": "Nel registro del primo operando",
        "image": null
      },
      {
        "text": "Nell'istruzione",
        "image": null
      },
      {
        "text": "Nel registro del secondo operando",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'istruzione addi è di tipo I (immediate) e codifica una costante numerica direttamente all'interno dei 16 bit del campo immediate dell'istruzione, non in un registro.",
    "hint": "Ricorda che il 'i' in addi sta per immediate e pensa al formato delle istruzioni di tipo I in MIPS."
  },
  {
    "question": "La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione n=0; con l'associazione n--> $s3 è:",
    "options": [
      {
        "text": "addi $s3, $zero, $zero",
        "image": null
      },
      {
        "text": "addi $zero, $s3, 0",
        "image": null
      },
      {
        "text": "add $zero, $s3, 0",
        "image": null
      },
      {
        "text": "addi $s3, $zero, 0",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Per inizializzare un registro a zero si usa addi con $zero (registro costante 0) come sorgente. La sintassi corretta è: addi destinazione, sorgente, immediato, quindi addi $s3, $zero, 0.",
    "hint": "Verifica l'ordine corretto degli operandi in addi: destinazione prima, poi sorgente, poi il valore immediato."
  },
  {
    "question": "La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione val=i-k; con l'associazione val--> $s1 i--> $s3 k--> $s2 è:",
    "options": [
      {
        "text": "sub $s1, $s2, $s3",
        "image": null
      },
      {
        "text": "sub $s2, $s3, $s1",
        "image": null
      },
      {
        "text": "sub $s3, $s2, $s1",
        "image": null
      },
      {
        "text": "sub $s1, $s3, $s2",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'istruzione sub in MIPS segue la sintassi: sub destinazione, sorgente1, sorgente2, calcolando sorgente1 - sorgente2. Quindi val=i-k richiede $s1 = $s3 - $s2.",
    "hint": "Ricorda che in sub il primo registro dopo l'opcode è la destinazione, seguito dal minuendo e poi dal sottraendo."
  },
  {
    "question": "La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione m=m+k; con l'associazione k--> $s3 m--> $s0 è:",
    "options": [
      {
        "text": "add $s3, $s0, $s0",
        "image": null
      },
      {
        "text": "add $s0, $s0, $s0",
        "image": null
      },
      {
        "text": "addi $s3, $s0, 2",
        "image": null
      },
      {
        "text": "add $s0, $s0, $s3",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'istruzione add somma due registri con sintassi: add destinazione, sorgente1, sorgente2. Per m=m+k, la destinazione è $s0 (m) che riceve la somma di $s0 (m) e $s3 (k).",
    "hint": "Il primo operando è il registro destinazione che riceverà il risultato della somma dei due operandi seguenti."
  },
  {
    "question": "Il numero di sequenze binarie diverse di lunghezza K è:",
    "options": [
      {
        "text": "Il numero 2K-1",
        "image": null
      },
      {
        "text": "Il numero 2K-1-1",
        "image": null
      },
      {
        "text": "Il numero 2K-1",
        "image": null
      },
      {
        "text": "Il numero 2K",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Ogni posizione della sequenza di lunghezza K può assumere 2 valori (0 o 1). Per il principio di moltiplicazione, il numero totale di sequenze distinte è 2^K, poiché le scelte sono indipendenti per ogni posizione.",
    "hint": "Considera quante scelte binarie hai per ciascuna delle K posizioni."
  },
  {
    "question": "In Notazione posizionale pesata il massimo valore rappresentabile con una sequenza binaria di lunghezza M è:",
    "options": [
      {
        "text": "Non limitato",
        "image": null
      },
      {
        "text": "Il valore 2M",
        "image": null
      },
      {
        "text": "Il valore 2M-1",
        "image": null
      },
      {
        "text": "Il valore 2M-1",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Con M bit, il valore massimo si ottiene quando tutti i bit valgono 1, corrispondente alla somma della serie geometrica 2^0 + 2^1 + ... + 2^(M-1) = 2^M - 1.",
    "hint": "Calcola il valore di una sequenza composta solo da cifre 1."
  },
  {
    "question": "La scelta dell'alfabeto binario consente di:",
    "options": [
      {
        "text": "Minimizzare l'errore dovuto ad oscillazioni del valore dei segnali elettrici",
        "image": null
      },
      {
        "text": "Minimizzare le connessioni tra le componenti interne del computer",
        "image": null
      },
      {
        "text": "Effettuare calcoli più semplici",
        "image": null
      },
      {
        "text": "Aumentare il numero di valori che si possono memorizzare nei registri",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "L'alfabeto binario utilizza due livelli di tensione distinti per rappresentare 0 e 1, creando un margine di rumore ampio che rende il sistema robusto contro oscillazioni e interferenze elettriche.",
    "hint": "Pensa alla distinzione tra livelli logici in presenza di disturbi fisici."
  },
  {
    "question": "In Notazione posizionale pesata la cifra più significativa di una sequenza è:",
    "options": [
      {
        "text": "La cifra più frequente all'interno della sequenza",
        "image": null
      },
      {
        "text": "La cifra che occupa la posizione più a sinistra",
        "image": null
      },
      {
        "text": "La cifra associata al peso di valore minore",
        "image": null
      },
      {
        "text": "La cifra che occupa la posizione più a destra",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Nella notazione posizionale, la cifra più a sinistra ha il peso maggiore (base^(n-1)) e contribuisce maggiormente al valore totale del numero rispetto alle altre cifre.",
    "hint": "Ricorda quale posizione ha il peso associato più elevato."
  },
  {
    "question": "In Notazione posizionale pesata una sequenza binaria con cifra meno significativa uguale a 0 rappresenta:",
    "options": [
      {
        "text": "Un numero pari",
        "image": null
      },
      {
        "text": "Un numero divisibile per 5",
        "image": null
      },
      {
        "text": "Un numero dispari",
        "image": null
      },
      {
        "text": "Un numero multiplo di 4",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "La cifra meno significativa (LSB) ha peso 2^0 = 1. Se è 0, il numero è divisibile per 2 (pari); se è 1, il numero è dispari.",
    "hint": "Considera il peso della cifra meno significativa e la divisibilità per 2."
  },
  {
    "question": "In Notazione posizionale pesata la cifra più significativa di una sequenza di lunghezza K è associata al peso:",
    "options": [
      {
        "text": "Dato dal valore 2K",
        "image": null
      },
      {
        "text": "Dato dal valore 20",
        "image": null
      },
      {
        "text": "Dato dal valore 2K-1",
        "image": null
      },
      {
        "text": "Dato dal valore 2K-1",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "In notazione posizionale pesata binaria, la cifra più significativa (MSB) occupa la posizione K-1 (contando da 0 da destra verso sinistra), quindi il suo peso è 2^(K-1). Questo perché ogni posizione rappresenta una potenza crescente di 2.",
    "hint": "Considera che la posizione più a sinistra in una sequenza di K bit corrisponde all'esponente K-1 nella base 2."
  },
  {
    "question": "In Notazione posizionale pesata il massimo valore che si può rappresentare nel contenuto di un registro del processore è:",
    "options": [
      {
        "text": "Il valore 232",
        "image": null
      },
      {
        "text": "Il valore 32",
        "image": null
      },
      {
        "text": "Il valore 232-1",
        "image": null
      },
      {
        "text": "Il valore 232-1",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Con n bit si possono rappresentare 2^n valori distinti nell'intervallo [0, 2^n-1]. Pertanto, il massimo valore rappresentabile in un registro a 32 bit è 2^32-1.",
    "hint": "Ricorda che con n bit contiamo da 0, quindi il valore massimo è uno meno del numero totale di combinazioni possibili."
  },
  {
    "question": "Per specificare l'indirizzo di un registro del processore MIPS occorre:",
    "options": [
      {
        "text": "Una sequenza di 32 bit",
        "image": null
      },
      {
        "text": "Una sequenza di 16 bit",
        "image": null
      },
      {
        "text": "Una sequenza di 8 bit",
        "image": null
      },
      {
        "text": "Una sequenza di 5 bit",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'architettura MIPS dispone di 32 registri general purpose, quindi per indirizzarli tutti univocamente sono necessari log₂(32) = 5 bit.",
    "hint": "Quanti registri general purpose ha l'architettura MIPS e quanti bit servono per distinguerli tutti?"
  },
  {
    "question": "Il risultato di un calcolo determina un overflow quando:",
    "options": [
      {
        "text": "Il calcolo è troppo complesso",
        "image": null
      },
      {
        "text": "La cifra più significativa della sequenza che rappresenta il risultato ha il valore 1",
        "image": null
      },
      {
        "text": "Per rappresentare il risultato è necessario un numero di bit maggiore della lunghezza dei registri del processore",
        "image": null
      },
      {
        "text": "Il risultato è uguale a 0",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'overflow si verifica quando il risultato di un'operazione eccede la capacità di rappresentazione del formato numerico, richiedendo più bit di quelli fisicamente disponibili nel registro destinazione.",
    "hint": "Cosa succede quando una somma supera il massimo valore esprimibile con i bit a disposizione del processore?"
  },
  {
    "question": "In Notazione posizionale pesata la sequenza binaria 11011 rappresenta il valore:",
    "options": [
      {
        "text": "Del numero 19 in base 10",
        "image": null
      },
      {
        "text": "Del numero 54 in base 10",
        "image": null
      },
      {
        "text": "Del numero 27 in base 10",
        "image": null
      },
      {
        "text": "Del numero 25 in base 10",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "La conversione si ottiene sommando le potenze di 2 corrispondenti alle posizioni degli 1: 1×2⁴ + 1×2³ + 0×2² + 1×2¹ + 1×2⁰ = 16 + 8 + 0 + 2 + 1 = 27.",
    "hint": "Calcola il valore posizionale di ogni bit 1 moltiplicandolo per la potenza di 2 corrispondente alla sua posizione (partendo da 0 da destra)."
  },
  {
    "question": "In Notazione posizionale pesata, l'addizione di due interi positivi si effettua:",
    "options": [
      {
        "text": "Ponendo a 0 il riporto trial cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da sinistra",
        "image": null
      },
      {
        "text": "Ponendo a 0 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da destra",
        "image": null
      },
      {
        "text": "Sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da sinistra",
        "image": null
      },
      {
        "text": "Ponendo a 1 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da destra",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Nell'addizione posizionale, l'algoritmo richiede di iniziare dalla cifra meno significativa (destra) con riporto iniziale 0, propagando eventuali riporti verso sinistra. Questo permette di gestire correttamente il carry tra le posizioni.",
    "hint": "L'addizione procede come fai normalmente con i numeri decimali: inizi dalle unità, non dalle cifre più a sinistra."
  },
  {
    "question": "Nella notazione in modulo e segno, il segno del risultato dell'addizione è:",
    "options": [
      {
        "text": "Sempre positivo",
        "image": null
      },
      {
        "text": "Quello del primo numero",
        "image": null
      },
      {
        "text": "Quello del numero con modulo maggiore",
        "image": null
      },
      {
        "text": "Quello del numero con modulo minore",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "In modulo e segno, quando si addizionano numeri con segni opposti si sottrae il modulo minore dal maggiore, e il risultato assume il segno del numero con modulo maggiore. Se i segni sono uguali, si sommano i moduli mantenendo il segno comune.",
    "hint": "Il risultato 'segue' il numero più grande in valore assoluto quando i segni sono discordi."
  },
  {
    "question": "Nella Notazione in complemento a 2, il peso del bit più a sinistra in una sequenza di lunghezza K è:",
    "options": [
      {
        "text": "Il valore -2K -1",
        "image": null
      },
      {
        "text": "Il valore -2K-1",
        "image": null
      },
      {
        "text": "Il valore -2K",
        "image": null
      },
      {
        "text": "Il valore +2K -1",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "In complemento a 2 con K bit, il bit più significativo ha peso -2^(K-1), consentendo la rappresentazione di numeri negativi. Gli altri K-1 bit mantengono pesi positivi standard.",
    "hint": "Il bit più a sinistra vale meno 2 elevato alla (lunghezza meno 1)."
  },
  {
    "question": "Nella Notazione in complemento a 2, il segno del numero è determinato da:",
    "options": [
      {
        "text": "Il bit più a destra con il relativo peso negativo",
        "image": null
      },
      {
        "text": "Il bit più a sinistra con il relativo peso negativo",
        "image": null
      },
      {
        "text": "Il bit della cifra meno significativa con il relativo peso negativo",
        "image": null
      },
      {
        "text": "Il bit più a sinistra non associato ad un peso",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "In complemento a 2, il bit più significativo (sinistra) determina il segno: se è 1 il numero è negativo (grazie al suo peso negativo -2^(K-1)), se è 0 è positivo. Questo bit funge quindi da indicatore di segno implicito.",
    "hint": "Il primo bit a sinistra vale negativo, quindi se è 1 il totale diventa negativo."
  },
  {
    "question": "Nella Notazione in complemento a 2, la somma di due interi con segni opposti viene eseguita:",
    "options": [
      {
        "text": "Sottraendo il numero di modulo minore dal numero di modulo maggiore",
        "image": null
      },
      {
        "text": "Addizionando al primo l'opposto del secondo",
        "image": null
      },
      {
        "text": "Sottraendo dal primo l'opposto del secondo",
        "image": null
      },
      {
        "text": "Addizionando i due numeri",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Il vantaggio principale del complemento a 2 è che l'addizione è identica per tutti i casi: si sommano direttamente i due numeri bit a bit, indipendentemente dai segni, senza necessità di sottrazioni o controlli preliminari. L'hardware si semplifica notevolmente.",
    "hint": "Il complemento a 2 unifica l'operazione di addizione per tutti i casi, eliminando la necessità di circuiti diversi per segni uguali o opposti."
  },
  {
    "question": "Nella Notazione in complemento a 2, il massimo numero rappresentabile con sequenze di lunghezza M è:",
    "options": [
      {
        "text": "Il valore 2M",
        "image": null
      },
      {
        "text": "Il valore 2M -1 -1",
        "image": null
      },
      {
        "text": "Il valore 2M -1",
        "image": null
      },
      {
        "text": "Il valore 2M -1",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "In complemento a 2 con M bit, il bit più significativo è riservato al segno, lasciando M-1 bit per la rappresentazione del valore. Il massimo numero positivo si ottiene con il bit di segno a 0 e tutti gli altri a 1, corrispondente a 2^{M-1} - 1.",
    "hint": "Considera che con M bit, solo M-1 sono disponibili per il valore assoluto quando il numero è positivo."
  },
  {
    "question": "Nella Notazione in complemento a 2, il minimo numero rappresentabile con sequenze di lunghezza M è:",
    "options": [
      {
        "text": "Il valore -2M -1",
        "image": null
      },
      {
        "text": "Il valore -2M",
        "image": null
      },
      {
        "text": "Il valore -2M -1",
        "image": null
      },
      {
        "text": "Il valore -2M -1 -1",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Il range del complemento a 2 è asimmetrico: lo zero occupa una codifica (tutti 0), lasciando una rappresentazione in più per i negativi. Il minimo si ottiene con il bit di segno 1 e tutti gli altri 0, corrispondente a -2^{M-1}.",
    "hint": "Ricorda che lo zero non ha doppia rappresentazione come in modulo e segno, riducendo di uno i numeri positivi disponibili."
  },
  {
    "question": "Nella Notazione in complemento a 2, la sequenza binaria 0101 rappresenta:",
    "options": [
      {
        "text": "Il valore +5",
        "image": null
      },
      {
        "text": "Il valore +3",
        "image": null
      },
      {
        "text": "Il valore -5",
        "image": null
      },
      {
        "text": "Il valore -3",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "Il bit più significativo è 0, indicando un numero positivo che si legge direttamente come binario naturale. La sequenza 101 in base 2 vale 4 + 1 = 5.",
    "hint": "Se il primo bit è 0, il numero è positivo e la conversione è immediata come binario puro."
  },
  {
    "question": "Nella Notazione in complemento a 2, la sequenza binaria 1001 rappresenta:",
    "options": [
      {
        "text": "Il valore +7",
        "image": null
      },
      {
        "text": "Il valore -5",
        "image": null
      },
      {
        "text": "Il valore -7",
        "image": null
      },
      {
        "text": "Il valore +5",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Il bit più significativo è 1, quindi il numero è negativo. Calcolando il complemento a 2 (inversione bit 0110 + 1 = 0111 = 7) o usando i pesi (-8 + 1 = -7), si ottiene il valore -7.",
    "hint": "Per trovare il valore di un numero negativo, inverti tutti i bit, somma 1, e applica il segno meno al risultato."
  },
  {
    "question": "Nella Notazione in complemento a 2, la sequenza binaria 1111 rappresenta:",
    "options": [
      {
        "text": "Il valore +15",
        "image": null
      },
      {
        "text": "Il valore -1",
        "image": null
      },
      {
        "text": "Il valore -7",
        "image": null
      },
      {
        "text": "Il valore +7",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "In complemento a 2, la sequenza con tutti bit a 1 rappresenta sempre -1, indipendentemente dalla lunghezza. Infatti, sommando 1 a 1111 si ottiene 10000 (overflow a 0 con riporto fuori).",
    "hint": "Prova a sommare 1 a questa sequenza binaria e osserva il risultato con overflow: che numero deve essere per tornare a zero?"
  },
  {
    "question": "In Notazione in complemento a 2, la rappresentazione dell'opposto del valore rappresentato da una sequenza di N bit si ottiene:",
    "options": [
      {
        "text": "Complementando la sequenza bit a bit ed aggiungendo il valore -2N",
        "image": null
      },
      {
        "text": "Complementando la sequenza bit a bit ed aggiungendo il valore 1",
        "image": null
      },
      {
        "text": "Cambiando il bit più significativo da 0 in 1 e da 1 in 0",
        "image": null
      },
      {
        "text": "Aggiungendo il valore 1 alla sequenza",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Nel complemento a 2, l'operazione di negazione richiede di calcolare il complemento a 1 (inversione bit a bit) e successivamente sommare 1 al risultato per ottenere il valore opposto. Questo metodo permette di rappresentare numeri negativi in modo univoco e di semplificare le operazioni aritmetiche.",
    "hint": "Ricorda che per ottenere l'inverso additivo in complemento a 2 devi applicare due operazioni successive alla sequenza di bit."
  },
  {
    "question": "In Notazione in complemento a 2, la sottrazione di due operandi si esegue:",
    "options": [
      {
        "text": "Addizionando al primo operando il secondo complementato bit a bit",
        "image": null
      },
      {
        "text": "Sottraendo dal primo operando il secondo",
        "image": null
      },
      {
        "text": "Addizionando al primo operando il secondo complementato bit a bit e sommato con il valore 1",
        "image": null
      },
      {
        "text": "Sottraendo l'operando con modulo minore da quello con modulo maggiore",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "La sottrazione A-B viene trasformata nell'addizione A+(-B), dove -B è rappresentato dal complemento a 2 di B, ottenuto appunto complementando i bit e sommando 1. Questo meccanismo consente di usare lo stesso circuito addizionatore per somme e sottrazioni.",
    "hint": "Pensa a come trasformare una sottrazione in un'addizione utilizzando la rappresentazione dell'opposto."
  },
  {
    "question": "La dichiarazione di tipo intero per una variabile in un Linguaggio ad Alto Livello indica al Compilatore che:",
    "options": [
      {
        "text": "Per la variabile si deve utilizzare la Notazione posizionale pesata",
        "image": null
      },
      {
        "text": "Per la variabile si deve utilizzare la Notazione con segno separato dal modulo",
        "image": null
      },
      {
        "text": "Per la variabile si deve utilizzare la Notazione in complemento a 2",
        "image": null
      },
      {
        "text": "La variabile ha segno positivo",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "I linguaggi ad alto livello utilizzano tipicamente la notazione in complemento a 2 per le variabili intere con segno, poiché è lo standard nelle architetture moderne per gestire efficientemente operazioni aritmetiche e rappresentazione dello zero. La dichiarazione di tipo guida il compilatore nell'allocazione e nella gestione dei bit.",
    "hint": "Considera quale rappresentazione binaria è universalmente adottata dai processori moderni per i numeri interi relativi."
  },
  {
    "question": "L'overflow può verificarsi:",
    "options": [
      {
        "text": "Addizionando numeri con lo stesso segno",
        "image": null
      },
      {
        "text": "Addizionando numeri con segni diversi",
        "image": null
      },
      {
        "text": "Mai con numeri negativi",
        "image": null
      },
      {
        "text": "Mai addizionando numeri con lo stesso segno",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "L'overflow si verifica quando il risultato di un'operazione eccede l'intervallo rappresentabile, cosa che può accadere sommando due numeri positivi (risultato troppo grande) o due negativi (risultato troppo piccolo). Al contrario, sommando numeri con segno opposto il risultato ha modulo inferiore e non può mai superare i limiti di rappresentazione.",
    "hint": "Refletti su quando il modulo del risultato può superare la capacità massima dei bit disponibili."
  },
  {
    "question": "In Notazione in complemento a 2, l'overflow viene segnalato quando gli ultimi due riporti cN e cN-1:",
    "options": [
      {
        "text": "Sono uguali",
        "image": null
      },
      {
        "text": "Hanno entrambi valore 0",
        "image": null
      },
      {
        "text": "Sono diversi",
        "image": null
      },
      {
        "text": "Hanno entrambi valore 1",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Nel controllo degli overflow per l'addizione in complemento a 2, si confrontano i riporti: quello entrante nel bit di segno (cN-1) e quello uscente (cN). Se questi due riporti differiscono, significa che il segno del risultato è errato rispetto agli operandi, segnalando così una condizione di overflow.",
    "hint": "Concentrati sui riporti che attraversano il bit più significativo durante l'addizione."
  },
  {
    "question": "In Notazione in complemento a 2, l'estensione del segno:",
    "options": [
      {
        "text": "Trasforma un numero positivo in negativo e viceversa",
        "image": null
      },
      {
        "text": "Aumenta la lunghezza di una sequenza aggiungendo cifre uguali a 0 a sinistra della cifra più significativa",
        "image": null
      },
      {
        "text": "Aumenta la lunghezza di una sequenza aggiungendo cifre uguali a 1 a sinistra della cifra più significativa",
        "image": null
      },
      {
        "text": "Aumenta la lunghezza di una sequenza senza modificarne il valore rappresentato",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'estensione del segno in complemento a 2 consiste nel replicare il bit più significativo verso sinistra per aumentare la lunghezza della rappresentazione mantenendo invariato il valore numerico, sia per numeri positivi che negativi.",
    "hint": "Pensa a cosa succede quando aggiungi zeri a sinistra di un positivo o uni a sinistra di un negativo."
  },
  {
    "question": "L'estensione del segno di una sequenza con bit più significativo uguale a 1 si effettua:",
    "options": [
      {
        "text": "Ponendo a sinistra di tale bit tutte cifre uguali a 1",
        "image": null
      },
      {
        "text": "Cambiando in 0 il valore di tale bit",
        "image": null
      },
      {
        "text": "Ponendo a sinistra di tale bit tutte cifre uguali a 0",
        "image": null
      },
      {
        "text": "Complementando la sequenza bit a bit ed aggiungendo 1",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "Quando il bit più significativo è 1 (numero negativo), l'estensione del segno richiede di aggiungere bit 1 a sinistra per preservare il valore negativo e mantenere la corretta rappresentazione in complemento a 2.",
    "hint": "Il bit di segno deve essere replicato per mantenere il segno originale durante l'estensione."
  },
  {
    "question": "Eseguendo un'addizione in Notazione in complemento a 2, se cN ha valore 0 e cN-1 ha valore 1:",
    "options": [
      {
        "text": "Il risultato è corretto",
        "image": null
      },
      {
        "text": "Il risultato è sbagliato",
        "image": null
      },
      {
        "text": "Il risultato ha solo il segno corretto",
        "image": null
      },
      {
        "text": "Il risultato ha solo il modulo corretto",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "In complemento a 2, l'overflow si verifica quando i riporti in ingresso (cN-1) e in uscita (cN) dal bit di segno differiscono. Se cN=0 e cN-1=1, c'è overflow e il risultato è errato.",
    "hint": "L'overflow si manifesta quando c'è un riporto nel bit di segno ma non fuori da esso."
  },
  {
    "question": "Eseguendo un'addizione in Notazione in complemento a 2, se cN ha valore 1 e cN-1 ha valore 1:",
    "options": [
      {
        "text": "Il risultato è sbagliato",
        "image": null
      },
      {
        "text": "Il risultato ha solo il segno corretto",
        "image": null
      },
      {
        "text": "Il risultato ha solo il modulo corretto",
        "image": null
      },
      {
        "text": "Il risultato è corretto",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Quando cN = cN-1 = 1, i riporti nel bit di segno e fuori dal bit di segno sono uguali, quindi non si verifica overflow. Questo accade tipicamente nella somma di due numeri negativi che generano un riporto finale corretto.",
    "hint": "Se i riporti sono identici (entrambi 0 o entrambi 1), non c'è overflow indipendentemente dal loro valore."
  },
  {
    "question": "Eseguendo un'addizione in Notazione in complemento a 2, i riporti cN e cN-1 che segnalano l'Overflow nell'Architettura MIPS sono:",
    "options": [
      {
        "text": "I riporti con indici c2 e c1",
        "image": null
      },
      {
        "text": "I riporti con indici c31 e c30",
        "image": null
      },
      {
        "text": "I riporti con indici c33 e c32",
        "image": null
      },
      {
        "text": "I riporti con indici c32 e c31",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Nell'architettura MIPS i registri sono a 32 bit, quindi il bit di segno è il bit 31. c31 rappresenta il riporto in ingresso al bit di segno, mentre c32 è il riporto in uscita. L'overflow si verifica quando c31 ≠ c32.",
    "hint": "Ricorda che in MIPS si parla di parole a 32 bit, quindi il bit più significativo è il 31."
  },
  {
    "question": "L'estensione del segno di una sequenza con bit più significativo uguale a 0 si effettua:",
    "options": [
      {
        "text": "Cambiando in 1 il valore di tale bit",
        "image": null
      },
      {
        "text": "Ponendo a sinistra di tale bit tutte cifre uguali a 1",
        "image": null
      },
      {
        "text": "Complementando la sequenza bit a bit ed aggiungendo 1",
        "image": null
      },
      {
        "text": "Ponendo a sinistra di tale bit tutte cifre uguali a 0",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'estensione del segno in complemento a due replica il bit più significativo (MSB) verso sinistra per preservare il valore numerico quando si aumenta la lunghezza in bit. Se il MSB è 0 (numero positivo), si aggiungono zeri a sinistra; se fosse 1, si aggiungerebbero uni.",
    "hint": "Pensa a come si preserva il valore di un numero positivo quando lo si rappresenta con più bit."
  },
  {
    "question": "Il Formato di una istruzione in Linguaggio Macchina è definito da:",
    "options": [
      {
        "text": "Una regola per il calcolo degli indirizzi degli operandi dell'istruzione",
        "image": null
      },
      {
        "text": "Una suddivisione fisica della sequenza binaria che rappresenta l'istruzione in sottosequenze di lunghezza e posizione fissata",
        "image": null
      },
      {
        "text": "Una suddivisione concettuale della sequenza binaria che rappresenta l'istruzione in sottosequenze di lunghezza e posizione fissata",
        "image": null
      },
      {
        "text": "Una regola che stabilisce la Notazione degli operandi dell'istruzione",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Il formato di istruzione definisce una suddivisione logica e concettuale della parola binaria in campi specifici (opcode, operandi, ecc.), ciascuno con una posizione e lunghezza prefissata. Non si tratta di una suddivisione fisica dei circuiti, ma di una convenzione di interpretazione dei bit.",
    "hint": "Considera che i bit rimangono fisicamente in sequenza, ma logicamente appartengono a campi diversi."
  },
  {
    "question": "La Modalità di Indirizzamento di una istruzione in Linguaggio Macchina stabilisce:",
    "options": [
      {
        "text": "La regola per suddividere in campi la sequenza binaria che rappresenta l'istruzione",
        "image": null
      },
      {
        "text": "La regola per determinare gli indirizzi degli operandi utilizzando il contenuto dei campi stabiliti dal Formato",
        "image": null
      },
      {
        "text": "La Notazione da utilizzare per la rappresentazione degli operandi dell'istruzione",
        "image": null
      },
      {
        "text": "La modalità di accesso in Memoria in lettura o in scrittura",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "La modalità di indirizzamento stabilisce la regola per calcolare l'indirizzo effettivo degli operandi a partire dai valori contenuti nei campi dell'istruzione, come registri base, offset o indirizzi immediati. Determina quindi come localizzare i dati necessari all'esecuzione.",
    "hint": "Distingui tra la struttura dell'istruzione (formato) e il metodo per trovare gli operandi (indirizzamento)."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, i campi del Formato di Tipo R sono:",
    "options": [
      {
        "text": "Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 8, 6, 6, 6, 6, 6",
        "image": null
      },
      {
        "text": "Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 6, 5, 5, 16",
        "image": null
      },
      {
        "text": "Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 5, 5, 5, 5, 6, 6",
        "image": null
      },
      {
        "text": "Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 6, 5, 5, 5, 5, 6",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Il formato R (Register) in MIPS è strutturato in 6 campi: opcode (6 bit), rs (5 bit), rt (5 bit), rd (5 bit), shamt (5 bit) e funct (6 bit), per un totale di 32 bit. Questo formato è utilizzato per le operazioni aritmetico-logiche tra registri.",
    "hint": "Ricorda che nel formato R ci sono tre registri (due sorgenti e uno destinazione) più i campi per opcode e funzione."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, il campo Codice Operativo di una istruzione stabilisce:",
    "options": [
      {
        "text": "La Notazione da adottare per gli operandi",
        "image": null
      },
      {
        "text": "L'indirizzo dove memorizzare il risultato dell'esecuzione dell'istruzione",
        "image": null
      },
      {
        "text": "L'operazione da eseguire ed il Formato dell'istruzione",
        "image": null
      },
      {
        "text": "Se l'istruzione è una addizione oppure una sottrazione",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "In MIPS, il campo opcode (6 bit) identifica l'operazione da eseguire e, conseguentemente, determina il formato dell'istruzione (R, I o J). Per le istruzioni di tipo R l'opcode è zero e il campo funct specifica l'operazione precisa, mentre per I e J l'opcode definisce direttamente l'istruzione.",
    "hint": "L'opcode influenza sia l'operazione che il modo in cui vengono interpretati i bit rimanenti dell'istruzione."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, il campo funct è:",
    "options": [
      {
        "text": "Un campo di 5 bit del Formato di Tipo R che indica l'indirizzo del registro che contiene il primo operando",
        "image": null
      },
      {
        "text": "Un campo di 6 bit del Formato di Tipo R che indica l'operazione Aritmetico-Logica da eseguire",
        "image": null
      },
      {
        "text": "Un campo di 6 bit del Formato di Tipo R che indica la modalità di indirizzamento dell'istruzione",
        "image": null
      },
      {
        "text": "Un campo di 5 bit del Formato di Tipo R che indica l'indirizzo del risultato della funzione eseguita dall'istruzione",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Nel formato R di MIPS, il campo opcode è sempre 0 per le istruzioni aritmetico-logiche, mentre il campo funct di 6 bit specifica l'operazione esatta da eseguire (es. add, sub, and, or).",
    "hint": "Ricorda che nel formato R l'opcode vale 0 e l'operazione specifica è codificata negli ultimi 6 bit dell'istruzione."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, con l'Indirizzamento tramite registro gli indirizzi degli operandi sono contenuti:",
    "options": [
      {
        "text": "Nei campi rt e shamt del Formato di Tipo R",
        "image": null
      },
      {
        "text": "Nei campi rd e funct del Formato di Tipo R",
        "image": null
      },
      {
        "text": "Nei campi rs e rt del Formato di Tipo I",
        "image": null
      },
      {
        "text": "Nei campi rs e rt del Formato di Tipo R",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Nell'indirizzamento tramite registro, gli operandi sorgente sono specificati dai campi rs e rt del formato R, che contengono gli indirizzi (numeri) dei registri dove sono memorizzati i dati da elaborare.",
    "hint": "Nel formato R, i campi da 5 bit subito dopo l'opcode indicano i registri sorgente, non il destinatario o lo spostamento."
  },
  {
    "question": "Le lunghezze dei campi dell'istruzione in Linguaggio Macchina MIPS che traduce l'istruzione Assembly add $t0, $s0, $s1 sono:",
    "options": [
      {
        "text": "I valori 6, 5, 5, 16",
        "image": null
      },
      {
        "text": "I valori 6, 5, 5, 5, 5, 6",
        "image": null
      },
      {
        "text": "I valori 7, 5, 5, 5, 5, 5",
        "image": null
      },
      {
        "text": "I valori 5, 5, 5, 5, 6, 6",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "L'istruzione `add` è di tipo R, il cui formato prevede 6 campi: opcode (6 bit), rs (5 bit), rt (5 bit), rd (5 bit), shamt (5 bit) e funct (6 bit), per un totale di 32 bit.",
    "hint": "Conta i bit dell'istruzione add: l'opcode è sempre 6 bit, poi ci sono tre registri e uno spostamento da 5 bit ciascuno, più il funct finale."
  },
  {
    "question": "Le istruzioni del Linguaggio Macchina MIPS con Codice operativo 0 hanno:",
    "options": [
      {
        "text": "Il Formato di Tipo I",
        "image": null
      },
      {
        "text": "Il Formato di Tipo S",
        "image": null
      },
      {
        "text": "Il Formato di Tipo R",
        "image": null
      },
      {
        "text": "Il Formato di Tipo J",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "In MIPS, il codice operativo 000000 (valore 0) identifica univocamente le istruzioni di tipo R, dove l'operazione specifica viene determinata dal campo funct anziché dall'opcode.",
    "hint": "Quando l'opcode è tutti zeri, l'istruzione appartiene al formato che usa il campo funct per distinguere le operazioni ALU."
  },
  {
    "question": "La suddivisione in campi dell'istruzione in Linguaggio Macchina MIPS 00000010000100010100000000100000 in base al suo Formato è data:",
    "options": [
      {
        "text": "Dalle sottosequenze 0000001, 000010001, 010000000, 0100000",
        "image": null
      },
      {
        "text": "Dalle sottosequenze 0000001, 00001, 00010, 10000, 00001, 00000",
        "image": null
      },
      {
        "text": "Dalle sottosequenze 000000, 10000, 10001, 01000, 00000, 100000",
        "image": null
      },
      {
        "text": "Dalle sottosequenze 000000, 10000, 10001, 0100000000100000",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "La stringa binaria rappresenta un'istruzione di tipo R che si suddivide in: opcode (6 bit: 000000), rs (5 bit: 10000), rt (5 bit: 10001), rd (5 bit: 01000), shamt (5 bit: 00000) e funct (6 bit: 100000).",
    "hint": "Dividi la sequenza di 32 bit in blocchi di 6-5-5-5-5-6, verificando che i primi 6 bit siano zeri (indicano formato R)."
  },
  {
    "question": "Nell'istruzione in Linguaggio Macchina MIPS con valori dei campi del Formato dati da 000000, 01000, 01001, 10000, 00000, 100010 l'indirizzo del registro che contiene il risultato è:",
    "options": [
      {
        "text": "Il campo 01000",
        "image": null
      },
      {
        "text": "Il campo 01001",
        "image": null
      },
      {
        "text": "Il campo 100010",
        "image": null
      },
      {
        "text": "Il campo 10000",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Nelle istruzioni MIPS di tipo R, il risultato dell'operazione viene memorizzato nel registro destinazione rd, che corrisponde al quarto campo (bit 15-11) della codifica. I campi seguono l'ordine: opcode (6 bit), rs (5 bit), rt (5 bit), rd (5 bit), shamt (5 bit), funct (6 bit).",
    "hint": "Identifica quale campo nell'istruzione di tipo R rappresenta il registro destinazione."
  },
  {
    "question": "L'operatore AND ha valore 1 quando:",
    "options": [
      {
        "text": "Un solo operando ha valore 1",
        "image": null
      },
      {
        "text": "Sempre",
        "image": null
      },
      {
        "text": "Gli operandi hanno entrambi valore 1",
        "image": null
      },
      {
        "text": "Almeno un operando ha valore 1",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'operatore AND realizza la congiunzione logica, che produce output 1 solo quando entrambi gli ingressi sono 1, secondo la tabella di verità della moltiplicazione logica. In tutti gli altri casi il risultato è 0.",
    "hint": "Pensa alla tabella di verità dell'operatore di congiunzione logica."
  },
  {
    "question": "L'operatore OR ha valore 0 quando:",
    "options": [
      {
        "text": "Gli operandi hanno entrambi valore 0",
        "image": null
      },
      {
        "text": "Mai",
        "image": null
      },
      {
        "text": "Un solo operando ha valore 0",
        "image": null
      },
      {
        "text": "Almeno un operando ha valore 0",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "L'operatore OR realizza la disgiunzione logica inclusiva, che produce output 0 solo quando entrambi gli operandi sono 0. Se almeno uno degli operandi è 1, il risultato è 1.",
    "hint": "Considera quando l'output di una porta OR è sicuramente falso."
  },
  {
    "question": "Per le istruzioni Aritmetico-Logiche del Linguaggio Macchina MIPS il campo Codice Operativo contiene:",
    "options": [
      {
        "text": "La sequenza di 5 bit 00000",
        "image": null
      },
      {
        "text": "La sequenza di 6 bit 100000",
        "image": null
      },
      {
        "text": "La sequenza di 6 bit 000000",
        "image": null
      },
      {
        "text": "La sequenza di 5 bit 00001",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Le istruzioni aritmetico-logiche in MIPS utilizzano il formato R, dove il campo opcode è sempre 000000 (6 bit zero) per indicare un'istruzione di tipo registro. L'operazione specifica è determinata dal campo funct.",
    "hint": "Ricorda quale pattern di bit identifica le istruzioni di tipo R in MIPS."
  },
  {
    "question": "Il Formato dell'istruzione in Linguaggio Macchina MIPS 00000010000100010100000000100101 è:",
    "options": [
      {
        "text": "Di Tipo I",
        "image": null
      },
      {
        "text": "Di Tipo K",
        "image": null
      },
      {
        "text": "Di Tipo J",
        "image": null
      },
      {
        "text": "Di Tipo R",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "I primi 6 bit dell'istruzione rappresentano il campo opcode: 000000 indica il formato R (Register), dove l'operazione è specificata dal campo funct negli ultimi 6 bit. Gli altri formati (I e J) hanno opcode diversi da zero.",
    "hint": "Analizza i primi 6 bit dell'istruzione per determinare il formato."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, il campo shamt del Formato di Tipo R contiene:",
    "options": [
      {
        "text": "L'indicazione di shift a sinistra o shift a destra",
        "image": null
      },
      {
        "text": "L'indirizzo del registro dell'operando",
        "image": null
      },
      {
        "text": "Il codice della funzione shift",
        "image": null
      },
      {
        "text": "Il numero di posizioni da scorrere nelle istruzioni di shift, altrimenti 0",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Il campo shamt (shift amount) nel formato R a 32 bit contiene il numero di posizioni di shift per istruzioni come sll, srl e sra (5 bit permettono valori 0-31). Per tutte le altre istruzioni aritmetico-logiche questo campo vale 0.",
    "hint": "Il nome 'shamt' deriva da 'shift amount' e specifica di quante posizioni spostare i bit."
  },
  {
    "question": "Nell'istruzione in Linguaggio Macchina MIPS con campi del Formato dati da 000000, 01000, 01001, 11110, 00000, 100101 gli indirizzi degli operandi sono:",
    "options": [
      {
        "text": "I valori binari 000000, 01000",
        "image": null
      },
      {
        "text": "I valori binari 01001, 11110",
        "image": null
      },
      {
        "text": "I valori binari 01000, 01001",
        "image": null
      },
      {
        "text": "I valori binari 10000, 100101",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Nel formato R, i campi rs (5 bit) e rt (5 bit) codificano i registri sorgente degli operandi, mentre rd (5 bit) è il registro destinazione. I valori 01000 (8) e 01001 (9) corrispondono ai campi rs e rt, cioè i registri $t0 e $t1.",
    "hint": "Nel formato R, i due operandi sorgente sono nei campi rs e rt, mentre rd è il risultato."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento delle istruzioni and ed or è:",
    "options": [
      {
        "text": "Immediato per entrambe",
        "image": null
      },
      {
        "text": "Tramite registro per entrambe",
        "image": null
      },
      {
        "text": "Di Tipo R per entrambe",
        "image": null
      },
      {
        "text": "Di Tipo I per entrambe",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Le istruzioni and e or standard in MIPS sono di tipo R e utilizzano l'indirizzamento a registro, operando su tre registri: due per gli operandi sorgente e uno per il risultato. Le versioni immediate (andi, ori) usano invece il formato I.",
    "hint": "Pensa alla differenza tra istruzioni che usano solo registri e quelle che usano un valore immediato."
  },
  {
    "question": "La traduzione in Assembly MIPS dell'OR bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $t0 è:",
    "options": [
      {
        "text": "L'istruzione or $s1, $s2, $t0",
        "image": null
      },
      {
        "text": "L'istruzione or t0, s1, s2",
        "image": null
      },
      {
        "text": "L'istruzione or $t0, $s1, $s2",
        "image": null
      },
      {
        "text": "L'istruzione or $s1, $t0, $s2",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "In MIPS, la sintassi delle istruzioni tipo R segue l'ordine: destinazione, sorgente1, sorgente2. Pertanto per memorizzare in $t0 il risultato di $s1 OR $s2 si usa or $t0, $s1, $s2.",
    "hint": "Ricorda che il primo registro dopo il mnemonico è sempre quello dove si salva il risultato."
  },
  {
    "question": "La traduzione in Assembly MIPS dello Shift a sinistra di 4 posizioni con registro operando $s3 e registro destinazione $t0 è:",
    "options": [
      {
        "text": "L'istruzione sll $s3, $t0, 4",
        "image": null
      },
      {
        "text": "L'istruzione shift $t0 , $s3, 4",
        "image": null
      },
      {
        "text": "L'istruzione sll $t0, $s3, 4",
        "image": null
      },
      {
        "text": "L'istruzione shift $s3, $t0, 4",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'istruzione sll (shift left logical) richiede la sintassi: registro destinazione, registro sorgente, numero di posizioni. Per shiftare $s3 di 4 bit verso sinistra e mettere il risultato in $t0 si scrive sll $t0, $s3, 4.",
    "hint": "L'istruzione MIPS per lo shift logico a sinistra è sll, non shift, e il primo operando è la destinazione."
  },
  {
    "question": "La traduzione in Assembly MIPS dell'AND bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $s5 è:",
    "options": [
      {
        "text": "L'istruzione and $s1, $s5, $s2",
        "image": null
      },
      {
        "text": "L'istruzione and $s1, $s2, $s5",
        "image": null
      },
      {
        "text": "L'istruzione and $s2, $s5, $s1",
        "image": null
      },
      {
        "text": "L'istruzione and $s5, $s1, $s2",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "In MIPS, la sintassi dell'istruzione and segue il formato Rd, Rs, Rt, dove Rd è il registro destinazione. Pertanto, per memorizzare il risultato in $s5 utilizzando $s1 e $s2 come operandi, la sintassi corretta è and $s5, $s1, $s2.",
    "hint": "Ricorda che in MIPS il primo registro specificato dopo l'opcode è il destinatario del risultato."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, i campi del Formato di Tipo I contengono:",
    "options": [
      {
        "text": "Sequenze di lunghezza 6, 5, 5, 5, 5, 6",
        "image": null
      },
      {
        "text": "Sequenze di lunghezza 6, 5, 5, 16",
        "image": null
      },
      {
        "text": "Sequenze di lunghezza 6, 16, 5, 5",
        "image": null
      },
      {
        "text": "Sequenze di lunghezza 6, 26",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Il formato di Tipo I (Immediate) in MIPS è strutturato in 4 campi: 6 bit per l'opcode, 5 bit per il registro sorgente (rs), 5 bit per il registro destinazione (rt) e 16 bit per il valore immediato.",
    "hint": "Le istruzioni di tipo I necessitano di un campo ampio per l'immediato a 16 bit."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, la suddivisione in campi dell'istruzione 00100001000010011000000000100101 con Formato di Tipo I è data:",
    "options": [
      {
        "text": "Dalle sequenze 0010000100001001, 10000, 00000, 100101",
        "image": null
      },
      {
        "text": "Dalle sequenze 001000, 01000, 01001, 10000, 00000, 100101",
        "image": null
      },
      {
        "text": "Dalle sequenze 001000, 01000, 010011000000000, 100101",
        "image": null
      },
      {
        "text": "Dalle sequenze 001000, 01000, 01001, 1000000000100101",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'istruzione binaria deve essere suddivisa secondo la struttura del formato I: 6 bit per l'opcode (001000), seguiti da 5 bit per rs (01000), 5 bit per rt (01001) e infine 16 bit per l'immediato (1000000000100101).",
    "hint": "Suddividi la sequenza binaria in gruppi di 6, 5, 5 e 16 bit partendo da sinistra."
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, il Formato e la Modalità di Indirizzamento dell'istruzione addi sono:",
    "options": [
      {
        "text": "Formato di Tipo R con Indirizzamento immediato",
        "image": null
      },
      {
        "text": "Formato di Tipo I con Indirizzamento immediato",
        "image": null
      },
      {
        "text": "Formato di Tipo I con Indirizzamento tramite registro",
        "image": null
      },
      {
        "text": "Formato di Tipo I sia con Indirizzamento tramite registro sia con Indirizzamento immediato",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "L'istruzione addi (add immediate) appartiene al formato di Tipo I perché include un valore immediato di 16 bit nel campo dedicato, utilizzando la modalità di indirizzamento immediato per operare con costanti.",
    "hint": "Il suffisso 'i' indica l'uso di un valore immediato tipico del formato I."
  },
  {
    "question": "La traduzione in Assembly MIPS dell'assegnamento val = b - 300 con l'associazione tra variabi e indirizzi di registri b-->$s1 e val-->$t0 è:",
    "options": [
      {
        "text": "L'istruzione sub $t0, $s1, 300",
        "image": null
      },
      {
        "text": "L'istruzione addi $t0, $s1, -300",
        "image": null
      },
      {
        "text": "L'istruzione addi $s1, $t0, -300",
        "image": null
      },
      {
        "text": "L'istruzione sub $s1, $t0, 300",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "Poiché MIPS non dispone dell'istruzione subi, per sottrarre una costante si utilizza addi con un immediato negativo. La sintassi addi $t0, $s1, -300 somma -300 al valore di $s1 e memorizza il risultato in $t0.",
    "hint": "Non esiste l'istruzione subi in MIPS; pensa a come trasformare una sottrazione in un'addizione."
  },
  {
    "question": "Nel Formato di Tipo I, i valori del campo immediato sono compresi tra:",
    "options": [
      {
        "text": "Il minimo -216 ed il massimo 216",
        "image": null
      },
      {
        "text": "Il minimo -215 ed il massimo 215",
        "image": null
      },
      {
        "text": "Il minimo 0 ed il massimo 216-1",
        "image": null
      },
      {
        "text": "Il minimo -215 ed il massimo 215-1",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Nel formato di tipo I, il campo immediato è composto da 16 bit. Utilizzando la rappresentazione in complemento a 2, il range di valori rappresentabili con n bit è [-2^(n-1), 2^(n-1)-1]. Con 16 bit si ottiene quindi [-2^15, 2^15-1].",
    "hint": "Ricorda che con 16 bit in complemento a 2, il bit più significativo è il segno e il range è asimmetrico."
  },
  {
    "question": "L'operando immediato dell'istruzione Assembly MIPS addi $t0, $s1, 30 è rappresentato in Linguaggio Macchina mediante:",
    "options": [
      {
        "text": "Una sequenza di 16 bit in Notazione posizionale pesata",
        "image": null
      },
      {
        "text": "Una sequenza di 16 bit in Notazione modulo e segno",
        "image": null
      },
      {
        "text": "Una sequenza di 16 bit in Notazione in complemento a 2",
        "image": null
      },
      {
        "text": "Una sequenza di 16 bit in Notazione posizionale pesata senza segno",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Le istruzioni di tipo I utilizzano un campo immediato di 16 bit codificato in complemento a 2 per rappresentare valori interi con segno, necessari per operazioni come l'addizione con costante (addi).",
    "hint": "Pensa a come vengono rappresentati i numeri negativi nell'immediato di istruzioni come addi."
  },
  {
    "question": "Prima della esecuzione di una istruzione con Formato di Tipo I il valore del campo immediato viene:",
    "options": [
      {
        "text": "Inviato all'ALU aggiungendo 16 bit uguali a 0 a sinistra della sequenza contenuta nel campo",
        "image": null
      },
      {
        "text": "Inviato all'ALU aggiungendo 16 bit uguali a 0 a destra della sequenza contenuta nel campo",
        "image": null
      },
      {
        "text": "Inviato all'ALU aggiungendo 16 bit mediante estensione del segno alla sequenza contenuta nel campo",
        "image": null
      },
      {
        "text": "Copiato in un registro di 32 bit",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Poiché l'ALU MIPS opera su operandi a 32 bit mentre il campo immediato è di soli 16 bit, è necessario estendere il segno (replicando il bit più significativo) per preservare il valore numerico corretto durante le operazioni aritmetiche.",
    "hint": "Considera cosa succederebbe a un numero negativo se aggiungessi semplicemente zeri a sinistra."
  },
  {
    "question": "La Modalità di Indirizzamento immediato è utilizzata con:",
    "options": [
      {
        "text": "Il formato di Tipo R e il Formato di Tipo I",
        "image": null
      },
      {
        "text": "Solo il Formato di Tipo I",
        "image": null
      },
      {
        "text": "Solo il Formato di Tipo R",
        "image": null
      },
      {
        "text": "Il formato di Tipo J",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "La modalità di indirizzamento immediato richiede un campo dedicato all'interno del formato istruzione per contenere la costante. Solo il formato di tipo I possiede questo campo da 16 bit, mentre il tipo R opera solo su registri e il tipo J su indirizzi di salto.",
    "hint": "Quale formato istruzione contiene un campo 'immediate' nella sua struttura binaria?"
  },
  {
    "question": "Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento immediato fornisce due operandi mediante due campi del Formato di Tipo I che contengono:",
    "options": [
      {
        "text": "Gli indirizzi dei registri che contengono i due operandi",
        "image": null
      },
      {
        "text": "Due numeri interi in Notazione in complemento a 2 che costituiscono i due operandi",
        "image": null
      },
      {
        "text": "I valori Codice Operativo e funzione",
        "image": null
      },
      {
        "text": "Un numero intero in Notazione in complemento a 2 che costituisce un operando e l'indirizzo di un registro che contiene l'altro operando",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Nel formato di tipo I, il campo rs (5 bit) specifica il registro sorgente contenente il primo operando, mentre il campo immediate (16 bit) fornisce il secondo operando come costante intera codificata in complemento a 2.",
    "hint": "Analizza la struttura del formato I: quali campi identificano i due operandi per l'ALU?"
  },
  {
    "question": "L'esecuzione dell'istruzione Assembly MIPS addi $s7, $t0, -35 ha l'effetto di:",
    "options": [
      {
        "text": "Addizionare -35 al contenuto del registro di indirizzo $s7 e scrivere il risultato come contenuto del registro di indirizzo $t0",
        "image": null
      },
      {
        "text": "Addizionare i contenuti dei registri di indirizzi $s7 e $t0 a -35 e scrivere il risultato come contenuto del registro di indirizzo $s7",
        "image": null
      },
      {
        "text": "Addizionare -35 al contenuto del registro di indirizzo $t0 e scrivere il risultato come contenuto del registro di indirizzo $s7",
        "image": null
      },
      {
        "text": "Copiare -35 nel registro di indirizzo $t0 e addizionare al contenuto del registro di indirizzo $s7",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'istruzione addi (add immediate) in MIPS segue la sintassi addi rt, rs, immediate, dove rs è il registro sorgente, immediate è la costante e rt è il registro destinazione. Quindi addi $s7, $t0, -35 calcola $t0 + (-35) e memorizza il risultato in $s7.",
    "hint": "Ricorda l'ordine degli operandi in addi: destinazione, sorgente, immediato."
  },
  {
    "question": "Gli indirizzi della Memoria principale MIPS sono dati da:",
    "options": [
      {
        "text": "Sequenze di 32 bit",
        "image": null
      },
      {
        "text": "Sequenze di 5 bit",
        "image": null
      },
      {
        "text": "Sequenze di 8 bit",
        "image": null
      },
      {
        "text": "Sequenze di 64 bit",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "L'architettura MIPS32 utilizza un bus indirizzi a 32 bit, permettendo di indirizzare 2^32 locazioni di memoria distinte. Questo è lo standard per la versione a 32 bit del processore MIPS.",
    "hint": "Considera la dimensione del registro PC e del bus indirizzi nell'architettura MIPS32."
  },
  {
    "question": "Le dimensioni di 1 Kappa, 1 Mega, 1 Giga corrisponsono:",
    "options": [
      {
        "text": "Ai valori 1 Kappa = circa un Milione, 1 Mega = circa un Miliardo, 1 Giga = circa Mille Miliardi",
        "image": null
      },
      {
        "text": "Ai valori 1 Kappa = circa Cento, 1 Mega = circa Mille, 1 Giga = circa un Milione",
        "image": null
      },
      {
        "text": "Ai valori 1 Kappa = circa Mille, 1 Mega = circa un Milione, 1 Giga = circa un Miliardo",
        "image": null
      },
      {
        "text": "Ai valori 1 Kappa = circa Mille, 1 Mega = circa 10 Milioni, 1 Giga = circa 10 Miliardi",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "I prefissi del Sistema Internazionale (SI) definiscono: kilo (K) = 10^3 (mille), mega (M) = 10^6 (milione), giga (G) = 10^9 (miliardo). Questi vengono usati per indicare multipli decimali nelle specifiche di memoria e storage.",
    "hint": "Pensa alle potenze di 10: 10^3, 10^6 e 10^9."
  },
  {
    "question": "Il numero di locazioni della Memoria principale MIPS è dato dal:",
    "options": [
      {
        "text": "Valore 25",
        "image": null
      },
      {
        "text": "Valore 232-1",
        "image": null
      },
      {
        "text": "Valore 232",
        "image": null
      },
      {
        "text": "Valore 231-1",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "Con indirizzi a 32 bit, il numero massimo di locazioni indirizzabili è 2^32, poiché ogni bit può assumere 2 valori e ci sono 32 bit. Questo corrisponde a circa 4 miliardi di locazioni di memoria.",
    "hint": "Se hai n bit per gli indirizzi, quante combinazioni uniche puoi rappresentare?"
  },
  {
    "question": "Il contenuto di una locazioni della Memoria principale MIPS è dato da:",
    "options": [
      {
        "text": "Una sequenza di 64 bit",
        "image": null
      },
      {
        "text": "Una sequenza di 32 bit",
        "image": null
      },
      {
        "text": "Una sequenza di 5 bit",
        "image": null
      },
      {
        "text": "Una sequenza di 8 bit",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "MIPS utilizza l'indirizzamento a byte (byte-addressable memory), dove ogni locazione di memoria corrisponde esattamente a un byte, ovvero una sequenza di 8 bit. Le word da 32 bit occupano 4 locazioni consecutive.",
    "hint": "Ricorda che 1 byte corrisponde a 8 bit e MIPS indirizza la memoria al livello del byte."
  },
  {
    "question": "In Assembly MIPS, l'operazione di leggere la parola che inizia all'indirizzo di Memoria calcolato tramite il registro Base di indirizzo $t1 e l'Offset 9 e scriverla nel registro di indirizzo $s2 è eseguita dalla:",
    "options": [
      {
        "text": "Istruzione sw $t1, 9 ($s2)",
        "image": null
      },
      {
        "text": "Istruzione lw $t1, 9 ($s2)",
        "image": null
      },
      {
        "text": "Istruzione sw $s2, 9 ($t1)",
        "image": null
      },
      {
        "text": "Istruzione lw $s2, 9 ($t1)",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'istruzione lw (load word) carica una parola dalla memoria in un registro. La sintassi è lw destinazione, offset(base), dove l'indirizzo effettivo si ottiene sommando l'offset al contenuto del registro base. Qui $s2 è la destinazione, $t1 è il base e 9 è l'offset.",
    "hint": "Ricorda che in lw il primo registro è la destinazione mentre il registro tra parentesi fornisce l'indirizzo base."
  },
  {
    "question": "L'istruzone Assembly MIPS lw $t5, 4($s0):",
    "options": [
      {
        "text": "Legge la parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro Base di indirizzo $t5 più l'Offset 4, e la scrive come contenuto del registro di indirizzo $s0",
        "image": null
      },
      {
        "text": "Legge la parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro Base di indirizzo $s0 più l'Offset 4, e la scrive come contenuto del registro di indirizzo $t5",
        "image": null
      },
      {
        "text": "Scrive il contenuto del registro di indirizzo $t5 nella parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro base di indirizzo $s0 più l'Offset 4",
        "image": null
      },
      {
        "text": "Scrive il contenuto del registro di indirizzo $s0 nella parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro base di indirizzo $t5 più l'Offset 4",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "L'istruzione lw utilizza la notazione lw registro_destinazione, offset(registro_base). L'indirizzo di memoria si calcola sommando l'offset 4 al contenuto di $s0, e il dato letto viene scritto in $t5. Non confondere il registro base con quello destinazione.",
    "hint": "Il registro prima della virgola riceve il dato, mentre quello tra parentesi specifica l'indirizzo base in memoria."
  },
  {
    "question": "In Assembly MIPS, l'operazione di scrittura del contenuto del registro di indirizzo $s3 nella parola che inizia all'indirizzo di Memoria calcolato tramite il registro Base di indirizzo $t0 e l'Offset 8 è eseguita dalla:",
    "options": [
      {
        "text": "Istruzione lw $s3, 8 ($t0)",
        "image": null
      },
      {
        "text": "Istruzione sw $t0, 8 ($s3)",
        "image": null
      },
      {
        "text": "Istruzione sw $s3, 8 ($t0)",
        "image": null
      },
      {
        "text": "Istruzione lw $t0, 8 ($s3)",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'istruzione sw (store word) scrive il contenuto di un registro in memoria. La sintassi è sw sorgente, offset(base), dove l'indirizzo di memoria è dato da base + offset. Qui $s3 è la sorgente, $t0 è il registro base e 8 è l'offset.",
    "hint": "Le istruzioni di store trasferiscono dati dal registro alla memoria, usando la stessa sintassi base+offset delle load."
  },
  {
    "question": "L'istruzone Assembly MIPS sw $t1, 4($s5):",
    "options": [
      {
        "text": "Legge la parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $s5 più l'Offset 4 e la scrive come contenuto del registro di indirizzo $t1",
        "image": null
      },
      {
        "text": "Scrive il contenuto del registro di indirizzo $s5 nella parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $t1 più l'Offset 4",
        "image": null
      },
      {
        "text": "Scrive il contenuto del registro di indirizzo $t1 nella parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $s5 più l'Offset 4",
        "image": null
      },
      {
        "text": "Legge la parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $t1 più l'Offset 4 e la scrive come contenuto del registro di indirizzo $s5",
        "image": null
      }
    ],
    "correctIndex": 2,
    "explanation": "L'istruzione sw memorizza il contenuto del primo registro ($t1) nella locazione di memoria il cui indirizzo è calcolato sommando l'offset (4) al contenuto del registro base ($s5). Questa operazione scrive in memoria, opposta alla lettura di lw.",
    "hint": "Con sw il flusso dati va dal registro verso la memoria, calcolando l'indirizzo con base più offset."
  },
  {
    "question": "Per l'istruzione load word la modalità di indirizzamento tramite Base e Offset calcola:",
    "options": [
      {
        "text": "L'indirizzo di una parola di Memoria da cui leggere un dato",
        "image": null
      },
      {
        "text": "L'indirizzo di un registro del processore da cui leggere un dato",
        "image": null
      },
      {
        "text": "L'indirizzo di una locazione di Memoria in cui scrivere un dato",
        "image": null
      },
      {
        "text": "L'indirizzo di un registro del processore in cui scrivere un dato",
        "image": null
      }
    ],
    "correctIndex": 0,
    "explanation": "Nell'indirizzamento base-plus-offset, il processore calcola l'indirizzo effettivo sommando l'offset al contenuto del registro base. Per l'istruzione lw, questo indirizzo punta a una locazione di memoria da cui leggere la parola da caricare nel registro destinazione.",
    "hint": "La modalità base+offset serve sempre a puntare a locazioni di memoria, non a registri del processore."
  },
  {
    "question": "Per l'istruzione store word la modalità di indirizzamento tramite Base e Offset calcola:",
    "options": [
      {
        "text": "L'indirizzo di un registro del processore in cui scrivere un dato",
        "image": null
      },
      {
        "text": "L'indirizzo di un registro del processore da cui leggere un dato",
        "image": null
      },
      {
        "text": "L'indirizzo di una locazione di Memoria da cui leggere un dato",
        "image": null
      },
      {
        "text": "L'indirizzo di una parola di Memoria in cui scrivere un dato",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "L'istruzione store word (sw) trasferisce dati dalla CPU alla memoria principale. La modalità base+offset calcola l'indirizzo effettivo sommando il contenuto del registro base all'offset, determinando la locazione di memoria destinataria del dato, non un registro.",
    "hint": "Rifletti sulla direzione del trasferimento dati quando si 'memorizza' qualcosa e su dove risiede fisicamente il dato destinazione."
  },
  {
    "question": "La traduzione in Assembly MIPS dell'assegnamento val = A[3], associando a val il registro di indirizzo $t0, ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $s1, è data da:",
    "options": [
      {
        "text": "L'istruzione sw $s1, 12 ($t0)",
        "image": null
      },
      {
        "text": "L'istruzione sw $t0, 12 ($s1)",
        "image": null
      },
      {
        "text": "L'istruzione lw $s1, 12 ($t0)",
        "image": null
      },
      {
        "text": "L'istruzione lw $t0, 12 ($s1)",
        "image": null
      }
    ],
    "correctIndex": 3,
    "explanation": "Per leggere un valore dalla memoria (accesso ad array) si utilizza l'istruzione lw (load word). La sintassi richiede il registro destinazione ($t0), l'offset calcolato come indice×4 (12 per A[3]) e il registro base ($s1), seguendo il formato lw rt, offset(base).",
    "hint": "Considera che tipo di operazione richiede leggere da memoria versus scrivere, e come si calcola lo spiazzamento per un array di interi."
  },
  {
    "question": "Il valore dell'Offset nell'istruzione Assembly MIPS lw $t0, 5($s3) è rappresentato nel Formato corrispondente in Linguaggio Macchina mediante:",
    "options": [
      {
        "text": "I 5 bit del campo rt del Formato di Tipo R",
        "image": null
      },
      {
        "text": "I 16 bit del campo immediato del Formato di Tipo I",
        "image": null
      },
      {
        "text": "I 6 bit del campo Funzione del Formato di Tipo R",
        "image": null
      },
      {
        "text": "I 5 bit del campo rs del Formato",
        "image": null
      }
    ],
    "correctIndex": 1,
    "explanation": "L'istruzione lw utilizza il formato di tipo I (Immediate), caratterizzato da un campo immediate di 16 bit che contiene proprio l'offset. Questo valore viene esteso in segno e sommato al registro base per calcolare l'indirizzo effettivo.",
    "hint": "Ricorda che le istruzioni di accesso alla memoria usano il formato I, non R, e individua quale campo ospita la costante numerica."
  }
]